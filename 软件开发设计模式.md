# 概述

**创建型模式（5种）：**

1. ✅ 单例模式 - 数据库连接池
2. ✅ 工厂方法模式 - 支付方式工厂
3. ✅ 抽象工厂模式 - 跨平台UI组件
4. ✅ 建造者模式 - HTTP请求构建器
5. ✅ 原型模式 - 游戏角色复制

**结构型模式（7种）：**

6. ✅ 适配器模式 - 第三方支付接口适配
7. ✅ 桥接模式 - 消息发送系统
8. ✅ 组合模式 - 公司组织架构
9. ✅ 装饰器模式 - 咖啡订单系统
10. ✅ 外观模式 - 智能家居控制
11. ✅ 享元模式 - 文本编辑器字符渲染
12. ✅ 代理模式 - 图片加载代理

**行为型模式（11种）：**

13. ✅ 责任链模式 - 请假审批系统
14. ✅ 命令模式 - 智能家居遥控器
15. ✅ 观察者模式 - 股票交易系统
16. ✅ 策略模式 - 电商促销系统
17. ✅ 状态模式 - 订单状态机
18. ✅ 模板方法模式 - 数据采集系统
19. ✅ 迭代器模式 - 书籍管理系统
20. ✅ 中介者模式 - 聊天室系统
21. ✅ 备忘录模式 - 文本编辑器
22. ✅ 访问者模式 - 员工薪资系统
23. ✅ 解释器模式

## 一、创建型模式

### 1. 单例模式（Singleton Pattern）

**使用场景**：

* 需要控制资源访问，如数据库连接池

* 配置管理器

* 日志记录器

* 线程池

**好处：**

- 控制实例数量，节省系统资源
- 提供全局访问点
- 避免对资源的多重占用（如文件操作）

**解决的问题：**

- 需要频繁创建和销毁的对象
- 创建对象耗时过多或耗资源过多
- 需要全局唯一的对象

**缺点：**

- 违反单一职责原则（既负责业务逻辑又控制实例化）
- 不利于扩展（难以被继承）
- 在多线程环境下需要特别注意
- 单元测试困难

**详细案例：数据库连接池管理器**

```java
/**
 * 数据库连接池单例
 * 场景：整个应用只需要一个连接池管理所有数据库连接
 */
public class DatabaseConnectionPool {
    private static volatile DatabaseConnectionPool instance;
    private List<Connection> connectionPool;
    private List<Connection> usedConnections = new ArrayList<>();
    private static final int INITIAL_POOL_SIZE = 10;
    private static final int MAX_POOL_SIZE = 20;

    // 私有构造函数
    private DatabaseConnectionPool() {
        connectionPool = new ArrayList<>(INITIAL_POOL_SIZE);
        for (int i = 0; i < INITIAL_POOL_SIZE; i++) {
            connectionPool.add(createConnection());
        }
    }

    // 双重检查锁定
    public static DatabaseConnectionPool getInstance() {
        if (instance == null) {
            synchronized (DatabaseConnectionPool.class) {
                if (instance == null) {
                    instance = new DatabaseConnectionPool();
                }
            }
        }
        return instance;
    }

    public synchronized Connection getConnection() {
        if (connectionPool.isEmpty()) {
            if (usedConnections.size() < MAX_POOL_SIZE) {
                connectionPool.add(createConnection());
            } else {
                throw new RuntimeException("连接池已满，无可用连接");
            }
        }

        Connection connection = connectionPool.remove(connectionPool.size() - 1);
        usedConnections.add(connection);
        return connection;
    }

    public synchronized boolean releaseConnection(Connection connection) {
        connectionPool.add(connection);
        return usedConnections.remove(connection);
    }

    private Connection createConnection() {
        try {
            return DriverManager.getConnection(
                "jdbc:mysql://localhost:3306/mydb", 
                "user", 
                "password"
            );
        } catch (SQLException e) {
            throw new RuntimeException("无法创建数据库连接", e);
        }
    }

    public int getPoolSize() {
        return connectionPool.size() + usedConnections.size();
    }
}

// 使用示例
public class OrderService {
    public void createOrder(Order order) {
        DatabaseConnectionPool pool = DatabaseConnectionPool.getInstance();
        Connection conn = null;
        try {
            conn = pool.getConnection();
            // 执行数据库操作
            PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO orders (id, amount) VALUES (?, ?)"
            );
            stmt.setString(1, order.getId());
            stmt.setBigDecimal(2, order.getAmount());
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (conn != null) {
                pool.releaseConnection(conn);
            }
        }
    }
}
```

### 2. 工厂方法模式（Factory Method Pattern）

**使用场景**：

* 创建复杂对象
* 需要根据条件创建不同对象
* 数据库访问层
* 日志记录器

**好处：**

- 解耦对象的创建和使用
- 符合开闭原则，易于扩展
- 符合单一职责原则

**解决的问题：**

- 对象创建逻辑复杂
- 需要根据不同条件创建不同对象
- 客户端不需要知道具体类名

**缺点：**

- 类的个数增加，增加系统复杂度
- 增加了系统的抽象性和理解难度

**详细案例：支付方式工厂**

```java
/**
 * 支付接口
 */
public interface Payment {
    PaymentResult pay(BigDecimal amount, String orderId);
    PaymentResult refund(String transactionId, BigDecimal amount);
    boolean isAvailable();
}

/**
 * 支付结果
 */
public class PaymentResult {
    private boolean success;
    private String transactionId;
    private String message;
    private LocalDateTime timestamp;

    // 构造函数、getter、setter省略
}

/**
 * 微信支付
 */
public class WeChatPayment implements Payment {
    private String appId;
    private String merchantId;
    private String apiKey;

    public WeChatPayment(String appId, String merchantId, String apiKey) {
        this.appId = appId;
        this.merchantId = merchantId;
        this.apiKey = apiKey;
    }

    @Override
    public PaymentResult pay(BigDecimal amount, String orderId) {
        System.out.println("使用微信支付，金额: " + amount);
        // 调用微信支付API
        String transactionId = "WX" + System.currentTimeMillis();

        // 模拟支付流程
        try {
            // 1. 构建支付参数
            Map<String, String> params = new HashMap<>();
            params.put("appid", appId);
            params.put("mch_id", merchantId);
            params.put("out_trade_no", orderId);
            params.put("total_fee", amount.multiply(new BigDecimal(100)).toString());

            // 2. 签名
            String sign = generateSign(params);

            // 3. 发起支付请求
            boolean success = callWeChatAPI(params, sign);

            return new PaymentResult(
                success, 
                transactionId, 
                "微信支付成功", 
                LocalDateTime.now()
            );
        } catch (Exception e) {
            return new PaymentResult(
                false, 
                null, 
                "微信支付失败: " + e.getMessage(), 
                LocalDateTime.now()
            );
        }
    }

    @Override
    public PaymentResult refund(String transactionId, BigDecimal amount) {
        System.out.println("微信退款，交易ID: " + transactionId);
        // 退款逻辑
        return new PaymentResult(true, transactionId, "退款成功", LocalDateTime.now());
    }

    @Override
    public boolean isAvailable() {
        // 检查微信支付是否可用
        return true;
    }

    private String generateSign(Map<String, String> params) {
        // 签名逻辑
        return "SIGN_" + apiKey;
    }

    private boolean callWeChatAPI(Map<String, String> params, String sign) {
        // 调用微信API
        return true;
    }
}

/**
 * 支付宝支付
 */
public class AliPayment implements Payment {
    private String partnerId;
    private String privateKey;

    public AliPayment(String partnerId, String privateKey) {
        this.partnerId = partnerId;
        this.privateKey = privateKey;
    }

    @Override
    public PaymentResult pay(BigDecimal amount, String orderId) {
        System.out.println("使用支付宝支付，金额: " + amount);
        String transactionId = "ALI" + System.currentTimeMillis();

        try {
            // 1. 构建支付参数
            Map<String, String> params = new HashMap<>();
            params.put("partner", partnerId);
            params.put("out_trade_no", orderId);
            params.put("total_amount", amount.toString());

            // 2. 使用私钥签名
            String sign = signWithPrivateKey(params);

            // 3. 调用支付宝API
            boolean success = callAlipayAPI(params, sign);

            return new PaymentResult(
                success, 
                transactionId, 
                "支付宝支付成功", 
                LocalDateTime.now()
            );
        } catch (Exception e) {
            return new PaymentResult(
                false, 
                null, 
                "支付宝支付失败: " + e.getMessage(), 
                LocalDateTime.now()
            );
        }
    }

    @Override
    public PaymentResult refund(String transactionId, BigDecimal amount) {
        System.out.println("支付宝退款，交易ID: " + transactionId);
        return new PaymentResult(true, transactionId, "退款成功", LocalDateTime.now());
    }

    @Override
    public boolean isAvailable() {
        return true;
    }

    private String signWithPrivateKey(Map<String, String> params) {
        return "SIGN_" + privateKey;
    }

    private boolean callAlipayAPI(Map<String, String> params, String sign) {
        return true;
    }
}

/**
 * 银行卡支付
 */
public class BankCardPayment implements Payment {
    private String bankCode;
    private String merchantId;

    public BankCardPayment(String bankCode, String merchantId) {
        this.bankCode = bankCode;
        this.merchantId = merchantId;
    }

    @Override
    public PaymentResult pay(BigDecimal amount, String orderId) {
        System.out.println("使用银行卡支付，金额: " + amount);
        String transactionId = "BANK" + System.currentTimeMillis();

        // 银行卡支付逻辑
        return new PaymentResult(
            true, 
            transactionId, 
            "银行卡支付成功", 
            LocalDateTime.now()
        );
    }

    @Override
    public PaymentResult refund(String transactionId, BigDecimal amount) {
        System.out.println("银行卡退款，交易ID: " + transactionId);
        return new PaymentResult(true, transactionId, "退款成功", LocalDateTime.now());
    }

    @Override
    public boolean isAvailable() {
        return true;
    }
}

/**
 * 支付工厂抽象类
 */
public abstract class PaymentFactory {
    /**
     * 工厂方法，由子类实现
     */
    public abstract Payment createPayment();

    /**
     * 模板方法，定义支付流程
     */
    public PaymentResult processPayment(BigDecimal amount, String orderId) {
        Payment payment = createPayment();

        // 支付前检查
        if (!payment.isAvailable()) {
            return new PaymentResult(
                false, 
                null, 
                "支付方式不可用", 
                LocalDateTime.now()
            );
        }

        // 执行支付
        PaymentResult result = payment.pay(amount, orderId);

        // 记录日志
        logPayment(result);

        return result;
    }

    private void logPayment(PaymentResult result) {
        System.out.println("支付日志: " + result.getMessage());
    }
}

/**
 * 微信支付工厂
 */
public class WeChatPaymentFactory extends PaymentFactory {
    @Override
    public Payment createPayment() {
        // 从配置中读取参数
        String appId = "wx123456789";
        String merchantId = "mch123456";
        String apiKey = "key123456789";

        return new WeChatPayment(appId, merchantId, apiKey);
    }
}

/**
 * 支付宝支付工厂
 */
public class AliPaymentFactory extends PaymentFactory {
    @Override
    public Payment createPayment() {
        String partnerId = "ali123456";
        String privateKey = "privatekey123";

        return new AliPayment(partnerId, privateKey);
    }
}

/**
 * 银行卡支付工厂
 */
public class BankCardPaymentFactory extends PaymentFactory {
    private String bankCode;

    public BankCardPaymentFactory(String bankCode) {
        this.bankCode = bankCode;
    }

    @Override
    public Payment createPayment() {
        String merchantId = "merchant123";
        return new BankCardPayment(bankCode, merchantId);
    }
}

/**
 * 使用示例
 */
public class PaymentDemo {
    public static void main(String[] args) {
        // 创建订单
        String orderId = "ORDER" + System.currentTimeMillis();
        BigDecimal amount = new BigDecimal("99.99");

        // 场景1：使用微信支付
        PaymentFactory weChatFactory = new WeChatPaymentFactory();
        PaymentResult result1 = weChatFactory.processPayment(amount, orderId);
        System.out.println("微信支付结果: " + result1.getMessage());

        // 场景2：使用支付宝支付
        PaymentFactory aliFactory = new AliPaymentFactory();
        PaymentResult result2 = aliFactory.processPayment(amount, orderId);
        System.out.println("支付宝支付结果: " + result2.getMessage());

        // 场景3：使用银行卡支付
        PaymentFactory bankFactory = new BankCardPaymentFactory("ICBC");
        PaymentResult result3 = bankFactory.processPayment(amount, orderId);
        System.out.println("银行卡支付结果: " + result3.getMessage());
    }
}
```

### 3. 抽象工厂模式（Abstract Factory Pattern）

**使用场景**：

* 创建相关产品族
* 跨平台UI组件
* 数据库迁移

**好处：**

- 确保产品族的一致性
- 易于交换产品系列
- 符合开闭原则

**解决的问题：**

- 需要创建一系列相关或相互依赖的对象
- 产品等级结构复杂

**缺点：**

- 增加新的产品等级结构复杂（需要修改抽象工厂接口）
- 增加了系统的抽象性

**详细案例：跨平台UI组件库**

```java
/**
 * 按钮接口
 */
public interface Button {
    void render();
    void onClick(Runnable action);
    void setStyle(String style);
}

/**
 * 输入框接口
 */
public interface TextField {
    void render();
    void setValue(String value);
    String getValue();
    void setPlaceholder(String placeholder);
}

/**
 * 复选框接口
 */
public interface Checkbox {
    void render();
    void setChecked(boolean checked);
    boolean isChecked();
}

/**
 * Windows风格按钮
 */
public class WindowsButton implements Button {
    private String style = "default";
    private Runnable clickHandler;

    @Override
    public void render() {
        System.out.println("渲染Windows风格按钮");
        System.out.println("  - 使用系统原生控件");
        System.out.println("  - 应用Windows主题");
        System.out.println("  - 样式: " + style);
    }

    @Override
    public void onClick(Runnable action) {
        this.clickHandler = action;
        System.out.println("Windows按钮绑定点击事件");
    }

    @Override
    public void setStyle(String style) {
        this.style = style;
    }

    public void click() {
        if (clickHandler != null) {
            clickHandler.run();
        }
    }
}

/**
 * Windows风格输入框
 */
public class WindowsTextField implements TextField {
    private String value = "";
    private String placeholder = "";

    @Override
    public void render() {
        System.out.println("渲染Windows风格输入框");
        System.out.println("  - 使用Win32 Edit控件");
        System.out.println("  - 占位符: " + placeholder);
    }

    @Override
    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public String getValue() {
        return value;
    }

    @Override
    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }
}

/**
 * Windows风格复选框
 */
public class WindowsCheckbox implements Checkbox {
    private boolean checked = false;

    @Override
    public void render() {
        System.out.println("渲染Windows风格复选框");
        System.out.println("  - 状态: " + (checked ? "选中" : "未选中"));
    }

    @Override
    public void setChecked(boolean checked) {
        this.checked = checked;
    }

    @Override
    public boolean isChecked() {
        return checked;
    }
}

/**
 * Mac风格按钮
 */
public class MacButton implements Button {
    private String style = "default";
    private Runnable clickHandler;

    @Override
    public void render() {
        System.out.println("渲染Mac风格按钮");
        System.out.println("  - 使用Cocoa控件");
        System.out.println("  - 应用macOS主题");
        System.out.println("  - 圆角设计，样式: " + style);
    }

    @Override
    public void onClick(Runnable action) {
        this.clickHandler = action;
        System.out.println("Mac按钮绑定点击事件");
    }

    @Override
    public void setStyle(String style) {
        this.style = style;
    }
}

/**
 * Mac风格输入框
 */
public class MacTextField implements TextField {
    private String value = "";
    private String placeholder = "";

    @Override
    public void render() {
        System.out.println("渲染Mac风格输入框");
        System.out.println("  - 使用NSTextField控件");
        System.out.println("  - 圆角边框");
        System.out.println("  - 占位符: " + placeholder);
    }

    @Override
    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public String getValue() {
        return value;
    }

    @Override
    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }
}

/**
 * Mac风格复选框
 */
public class MacCheckbox implements Checkbox {
    private boolean checked = false;

    @Override
    public void render() {
        System.out.println("渲染Mac风格复选框");
        System.out.println("  - 使用开关样式");
        System.out.println("  - 状态: " + (checked ? "开启" : "关闭"));
    }

    @Override
    public void setChecked(boolean checked) {
        this.checked = checked;
    }

    @Override
    public boolean isChecked() {
        return checked;
    }
}

/**
 * Linux风格按钮
 */
public class LinuxButton implements Button {
    private String style = "default";
    private Runnable clickHandler;

    @Override
    public void render() {
        System.out.println("渲染Linux风格按钮");
        System.out.println("  - 使用GTK控件");
        System.out.println("  - 应用Linux主题");
        System.out.println("  - 样式: " + style);
    }

    @Override
    public void onClick(Runnable action) {
        this.clickHandler = action;
    }

    @Override
    public void setStyle(String style) {
        this.style = style;
    }
}

/**
 * Linux风格输入框
 */
public class LinuxTextField implements TextField {
    private String value = "";
    private String placeholder = "";

    @Override
    public void render() {
        System.out.println("渲染Linux风格输入框");
        System.out.println("  - 使用GtkEntry控件");
        System.out.println("  - 占位符: " + placeholder);
    }

    @Override
    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public String getValue() {
        return value;
    }

    @Override
    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }
}

/**
 * Linux风格复选框
 */
public class LinuxCheckbox implements Checkbox {
    private boolean checked = false;

    @Override
    public void render() {
        System.out.println("渲染Linux风格复选框");
        System.out.println("  - 使用GtkCheckButton");
        System.out.println("  - 状态: " + (checked ? "勾选" : "未勾选"));
    }

    @Override
    public void setChecked(boolean checked) {
        this.checked = checked;
    }

    @Override
    public boolean isChecked() {
        return checked;
    }
}

/**
 * UI组件工厂接口
 */
public interface UIFactory {
    Button createButton();
    TextField createTextField();
    Checkbox createCheckbox();
}

/**
 * Windows UI工厂
 */
public class WindowsUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }

    @Override
    public TextField createTextField() {
        return new WindowsTextField();
    }

    @Override
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

/**
 * Mac UI工厂
 */
public class MacUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }

    @Override
    public TextField createTextField() {
        return new MacTextField();
    }

    @Override
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

/**
 * Linux UI工厂
 */
public class LinuxUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new LinuxButton();
    }

    @Override
    public TextField createTextField() {
        return new LinuxTextField();
    }

    @Override
    public Checkbox createCheckbox() {
        return new LinuxCheckbox();
    }
}

/**
 * 应用程序类
 */
public class Application {
    private Button button;
    private TextField textField;
    private Checkbox checkbox;

    public Application(UIFactory factory) {
        this.button = factory.createButton();
        this.textField = factory.createTextField();
        this.checkbox = factory.createCheckbox();
    }

    public void render() {
        System.out.println("========== 渲染应用程序界面 ==========");
        button.render();
        textField.render();
        checkbox.render();
        System.out.println("====================================\n");
    }

    public void setupLoginForm() {
        System.out.println("========== 配置登录表单 ==========");

        textField.setPlaceholder("请输入用户名");
        textField.render();

        checkbox.setChecked(false);
        checkbox.render();

        button.setStyle("primary");
        button.onClick(() -> {
            String username = textField.getValue();
            boolean rememberMe = checkbox.isChecked();
            System.out.println("登录: 用户名=" + username + ", 记住我=" + rememberMe);
        });
        button.render();

        System.out.println("================================\n");
    }
}

/**
 * 使用示例
 */
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        // 检测操作系统
        String os = detectOS();
        System.out.println("检测到操作系统: " + os + "\n");

        // 根据操作系统选择工厂
        UIFactory factory;
        if (os.equals("Windows")) {
            factory = new WindowsUIFactory();
        } else if (os.equals("Mac")) {
            factory = new MacUIFactory();
        } else {
            factory = new LinuxUIFactory();
        }

        // 创建应用程序
        Application app = new Application(factory);

        // 渲染界面
        app.render();

        // 配置登录表单
        app.setupLoginForm();
    }

    private static String detectOS() {
        // 模拟检测操作系统
        // 实际可以通过 System.getProperty("os.name") 获取
        return "Windows"; // 可以改为 "Mac" 或 "Linux" 测试
    }
}
```

### 4. 建造者模式（Builder Pattern）

**使用场景**：

* 创建复杂对象
* 需要多种表示的对象
* 参数较多且有默认值

**好处：**

- 将构造代码与表示代码分离
- 可以精细控制构造过程
- 可以复用相同的构造过程创建不同表示

**解决的问题：**

- 对象有多个可选参数
- 构造函数参数过多
- 需要创建不可变对象

**缺点：**

- 产生多余的Builder对象
- 代码量增加

**详细案例：HTTP请求构建器**

```java
/**
 * HTTP请求类
 */
public class HttpRequest {
    // 必需参数
    private final String url;
    private final String method;

    // 可选参数
    private final Map<String, String> headers;
    private final Map<String, String> queryParams;
    private final String body;
    private final int timeout;
    private final int retryCount;
    private final boolean followRedirects;
    private final String userAgent;
    private final Map<String, String> cookies;
    private final String contentType;
    private final String charset;

    // 私有构造函数
    private HttpRequest(Builder builder) {
        this.url = builder.url;
        this.method = builder.method;
        this.headers = builder.headers;
        this.queryParams = builder.queryParams;
        this.body = builder.body;
        this.timeout = builder.timeout;
        this.retryCount = builder.retryCount;
        this.followRedirects = builder.followRedirects;
        this.userAgent = builder.userAgent;
        this.cookies = builder.cookies;
        this.contentType = builder.contentType;
        this.charset = builder.charset;
    }

    /**
     * 执行HTTP请求
     */
    public HttpResponse execute() {
        System.out.println("========== 执行HTTP请求 ==========");
        System.out.println("URL: " + getFullUrl());
        System.out.println("Method: " + method);
        System.out.println("Headers: " + headers);
        System.out.println("Body: " + body);
        System.out.println("Timeout: " + timeout + "ms");
        System.out.println("Retry Count: " + retryCount);
        System.out.println("================================\n");

        // 模拟HTTP请求
        try {
            Thread.sleep(100); // 模拟网络延迟
            return new HttpResponse(200, "Success", "{\"status\": \"ok\"}");
        } catch (InterruptedException e) {
            return new HttpResponse(500, "Error", null);
        }
    }

    private String getFullUrl() {
        if (queryParams.isEmpty()) {
            return url;
        }

        StringBuilder sb = new StringBuilder(url);
        sb.append("?");
        queryParams.forEach((key, value) -> 
            sb.append(key).append("=").append(value).append("&")
        );
        return sb.substring(0, sb.length() - 1);
    }

    /**
     * 建造者类
     */
    public static class Builder {
        // 必需参数
        private final String url;
        private String method = "GET";

        // 可选参数 - 初始化默认值
        private Map<String, String> headers = new HashMap<>();
        private Map<String, String> queryParams = new HashMap<>();
        private String body = null;
        private int timeout = 5000;
        private int retryCount = 0;
        private boolean followRedirects = true;
        private String userAgent = "MyHttpClient/1.0";
        private Map<String, String> cookies = new HashMap<>();
        private String contentType = "application/json";
        private String charset = "UTF-8";

        /**
         * 构造器需要必需参数
         */
        public Builder(String url) {
            if (url == null || url.isEmpty()) {
                throw new IllegalArgumentException("URL不能为空");
            }
            this.url = url;
        }

        public Builder method(String method) {
            this.method = method;
            return this;
        }

        public Builder get() {
            return method("GET");
        }

        public Builder post() {
            return method("POST");
        }

        public Builder put() {
            return method("PUT");
        }

        public Builder delete() {
            return method("DELETE");
        }

        public Builder header(String key, String value) {
            this.headers.put(key, value);
            return this;
        }

        public Builder headers(Map<String, String> headers) {
            this.headers.putAll(headers);
            return this;
        }

        public Builder queryParam(String key, String value) {
            this.queryParams.put(key, value);
            return this;
        }

        public Builder queryParams(Map<String, String> params) {
            this.queryParams.putAll(params);
            return this;
        }

        public Builder body(String body) {
            this.body = body;
            return this;
        }

        public Builder jsonBody(Object obj) {
            // 简化示例，实际应使用JSON库
            this.body = obj.toString();
            this.contentType = "application/json";
            return this;
        }

        public Builder timeout(int timeout) {
            if (timeout < 0) {
                throw new IllegalArgumentException("超时时间不能为负数");
            }
            this.timeout = timeout;
            return this;
        }

        public Builder retryCount(int retryCount) {
            if (retryCount < 0) {
                throw new IllegalArgumentException("重试次数不能为负数");
            }
            this.retryCount = retryCount;
            return this;
        }

        public Builder followRedirects(boolean follow) {
            this.followRedirects = follow;
            return this;
        }

        public Builder userAgent(String userAgent) {
            this.userAgent = userAgent;
            return this;
        }

        public Builder cookie(String key, String value) {
            this.cookies.put(key, value);
            return this;
        }

        public Builder contentType(String contentType) {
            this.contentType = contentType;
            return this;
        }

        public Builder charset(String charset) {
            this.charset = charset;
            return this;
        }

        /**
         * 构建HttpRequest对象
         */
        public HttpRequest build() {
            // 添加默认headers
            if (!headers.containsKey("Content-Type")) {
                headers.put("Content-Type", contentType + "; charset=" + charset);
            }
            if (!headers.containsKey("User-Agent")) {
                headers.put("User-Agent", userAgent);
            }

            // 添加cookies到header
            if (!cookies.isEmpty()) {
                String cookieString = cookies.entrySet().stream()
                    .map(e -> e.getKey() + "=" + e.getValue())
                    .collect(Collectors.joining("; "));
                headers.put("Cookie", cookieString);
            }

            return new HttpRequest(this);
        }
    }
}

/**
 * HTTP响应类
 */
public class HttpResponse {
    private final int statusCode;
    private final String statusMessage;
    private final String body;

    public HttpResponse(int statusCode, String statusMessage, String body) {
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
        this.body = body;
    }

    public int getStatusCode() {
        return statusCode;
    }

    public String getBody() {
        return body;
    }

    public boolean isSuccess() {
        return statusCode >= 200 && statusCode < 300;
    }
}

/**
 * 使用示例
 */
public class BuilderDemo {
    public static void main(String[] args) {
        // 场景1：简单的GET请求
        HttpRequest request1 = new HttpRequest.Builder("https://api.example.com/users")
            .get()
            .queryParam("page", "1")
            .queryParam("size", "10")
            .build();

        HttpResponse response1 = request1.execute();
        System.out.println("响应状态码: " + response1.getStatusCode() + "\n");

        // 场景2：复杂的POST请求
        Map<String, String> customHeaders = new HashMap<>();
        customHeaders.put("X-API-Key", "your-api-key");
        customHeaders.put("X-Request-ID", UUID.randomUUID().toString());

        HttpRequest request2 = new HttpRequest.Builder("https://api.example.com/orders")
            .post()
            .headers(customHeaders)
            .jsonBody("{\"productId\": \"123\", \"quantity\": 2}")
            .timeout(10000)
            .retryCount(3)
            .cookie("sessionId", "abc123")
            .userAgent("MyApp/2.0")
            .build();

        HttpResponse response2 = request2.execute();
        System.out.println("响应状态码: " + response2.getStatusCode() + "\n");

        // 场景3：文件上传请求
        HttpRequest request3 = new HttpRequest.Builder("https://api.example.com/upload")
            .post()
            .header("Authorization", "Bearer token123")
            .contentType("multipart/form-data")
            .body("file content here")
            .timeout(30000)
            .followRedirects(false)
            .build();

        HttpResponse response3 = request3.execute();
        System.out.println("响应状态码: " + response3.getStatusCode());
    }
}
```

### 5. 原型模式（Prototype Pattern）

**使用场景**：

* 对象创建成本较高
* 需要大量相似对象
* 需要保存对象状态

**好处：**

- 性能优良（避免重复初始化）
- 简化对象创建过程
- 可以动态添加或删除对象

**解决的问题：**

- 对象创建成本高（数据库查询、网络请求）
- 需要创建大量相似对象

**缺点：**

- 需要为每个类配置克隆方法
- 深拷贝和浅拷贝需要仔细处理
- 循环引用问题

**详细案例：游戏角色复制系统**

```java
/**
 * 装备类
 */
public class Equipment implements Cloneable {
    private String name;
    private int attack;
    private int defense;
    private int level;

    public Equipment(String name, int attack, int defense, int level) {
        this.name = name;
        this.attack = attack;
        this.defense = defense;
        this.level = level;
    }

    @Override
    public Equipment clone() {
        try {
            return (Equipment) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String toString() {
        return String.format("%s(攻击+%d,防御+%d,等级%d)", 
            name, attack, defense, level);
    }

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAttack() { return attack; }
    public int getDefense() { return defense; }
    public int getLevel() { return level; }
}

/**
 * 技能类
 */
public class Skill implements Cloneable {
    private String name;
    private int damage;
    private int manaCost;
    private int cooldown;

    public Skill(String name, int damage, int manaCost, int cooldown) {
        this.name = name;
        this.damage = damage;
        this.manaCost = manaCost;
        this.cooldown = cooldown;
    }

    @Override
    public Skill clone() {
        try {
            return (Skill) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String toString() {
        return String.format("%s(伤害%d,魔法消耗%d,冷却%ds)", 
            name, damage, manaCost, cooldown);
    }

    // Getters
    public String getName() { return name; }
    public int getDamage() { return damage; }
}

/**
 * 游戏角色类
 */
public class GameCharacter implements Cloneable {
    private String name;
    private String characterClass;
    private int level;
    private int health;
    private int mana;
    private int attack;
    private int defense;

    // 复杂对象
    private List<Equipment> equipments;
    private List<Skill> skills;
    private Map<String, Integer> attributes;

    public GameCharacter(String name, String characterClass) {
        this.name = name;
        this.characterClass = characterClass;
        this.level = 1;
        this.equipments = new ArrayList<>();
        this.skills = new ArrayList<>();
        this.attributes = new HashMap<>();

        // 初始化基础属性（耗时操作）
        initializeBaseStats();
    }

    /**
     * 模拟耗时的初始化操作
     */
    private void initializeBaseStats() {
        System.out.println("正在初始化角色 " + name + " 的基础属性...");

        // 根据职业设置属性
        switch (characterClass) {
            case "战士":
                this.health = 1000;
                this.mana = 200;
                this.attack = 100;
                this.defense = 80;
                break;
            case "法师":
                this.health = 500;
                this.mana = 800;
                this.attack = 120;
                this.defense = 30;
                break;
            case "刺客":
                this.health = 700;
                this.mana = 300;
                this.attack = 150;
                this.defense = 50;
                break;
            default:
                this.health = 800;
                this.mana = 400;
                this.attack = 80;
                this.defense = 60;
        }

        // 模拟从数据库加载属性
        try {
            Thread.sleep(100); // 模拟耗时操作
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("角色初始化完成！\n");
    }

    /**
     * 深拷贝克隆方法
     */
    @Override
    public GameCharacter clone() {
        try {
            // 浅拷贝基础类型
            GameCharacter cloned = (GameCharacter) super.clone();

            // 深拷贝装备列表
            cloned.equipments = new ArrayList<>();
            for (Equipment equipment : this.equipments) {
                cloned.equipments.add(equipment.clone());
            }

            // 深拷贝技能列表
            cloned.skills = new ArrayList<>();
            for (Skill skill : this.skills) {
                cloned.skills.add(skill.clone());
            }

            // 深拷贝属性Map
            cloned.attributes = new HashMap<>(this.attributes);

            System.out.println("通过克隆创建角色副本（避免了耗时的初始化）");

            return cloned;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("克隆失败", e);
        }
    }

    /**
     * 浅拷贝克隆方法（用于对比）
     */
    public GameCharacter shallowClone() {
        try {
            return (GameCharacter) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("克隆失败", e);
        }
    }

    public void addEquipment(Equipment equipment) {
        this.equipments.add(equipment);
        // 装备影响属性
        this.attack += equipment.getAttack();
        this.defense += equipment.getDefense();
    }

    public void addSkill(Skill skill) {
        this.skills.add(skill);
    }

    public void setAttribute(String key, int value) {
        this.attributes.put(key, value);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void displayInfo() {
        System.out.println("========== 角色信息 ==========");
        System.out.println("名称: " + name);
        System.out.println("职业: " + characterClass);
        System.out.println("等级: " + level);
        System.out.println("生命值: " + health);
        System.out.println("魔法值: " + mana);
        System.out.println("攻击力: " + attack);
        System.out.println("防御力: " + defense);

        if (!equipments.isEmpty()) {
            System.out.println("\n装备:");
            equipments.forEach(e -> System.out.println("  - " + e));
        }

        if (!skills.isEmpty()) {
            System.out.println("\n技能:");
            skills.forEach(s -> System.out.println("  - " + s));
        }

        if (!attributes.isEmpty()) {
            System.out.println("\n特殊属性:");
            attributes.forEach((k, v) -> 
                System.out.println("  - " + k + ": " + v));
        }

        System.out.println("=============================\n");
    }
}

/**
 * 角色管理器（原型注册表）
 */
public class CharacterRegistry {
    private Map<String, GameCharacter> prototypes = new HashMap<>();

    /**
     * 注册原型
     */
    public void registerPrototype(String key, GameCharacter prototype) {
        prototypes.put(key, prototype);
        System.out.println("注册角色模板: " + key);
    }

    /**
     * 克隆原型
     */
    public GameCharacter getPrototype(String key) {
        GameCharacter prototype = prototypes.get(key);
        if (prototype != null) {
            return prototype.clone();
        }
        return null;
    }

    /**
     * 初始化默认角色模板
     */
    public void initializeDefaultCharacters() {
        System.out.println("========== 初始化角色模板 ==========\n");

        // 创建战士模板
        GameCharacter warrior = new GameCharacter("战士模板", "战士");
        warrior.addEquipment(new Equipment("铁剑", 30, 0, 1));
        warrior.addEquipment(new Equipment("铁甲", 0, 40, 1));
        warrior.addSkill(new Skill("重击", 200, 50, 5));
        warrior.setAttribute("暴击率", 15);
        registerPrototype("warrior", warrior);

        // 创建法师模板
        GameCharacter mage = new GameCharacter("法师模板", "法师");
        mage.addEquipment(new Equipment("魔杖", 50, 0, 1));
        mage.addEquipment(new Equipment("法袍", 0, 20, 1));
        mage.addSkill(new Skill("火球术", 300, 100, 3));
        mage.addSkill(new Skill("冰冻术", 250, 80, 4));
        mage.setAttribute("施法速度", 20);
        registerPrototype("mage", mage);

        // 创建刺客模板
        GameCharacter assassin = new GameCharacter("刺客模板", "刺客");
        assassin.addEquipment(new Equipment("匕首", 45, 0, 1));
        assassin.addEquipment(new Equipment("皮甲", 0, 30, 1));
        assassin.addSkill(new Skill("背刺", 400, 60, 8));
        assassin.setAttribute("闪避率", 25);
        assassin.setAttribute("暴击率", 35);
        registerPrototype("assassin", assassin);

        System.out.println("=====================================\n");
    }
}

/**
 * 使用示例
 */
public class PrototypeDemo {
    public static void main(String[] args) {
        CharacterRegistry registry = new CharacterRegistry();

        // 初始化角色模板（耗时操作只需要执行一次）
        registry.initializeDefaultCharacters();

        // 场景1：快速创建多个战士角色
        System.out.println("========== 场景1：创建战士团队 ==========\n");
        long startTime = System.currentTimeMillis();

        GameCharacter warrior1 = registry.getPrototype("warrior");
        warrior1.setName("战士-张三");

        GameCharacter warrior2 = registry.getPrototype("warrior");
        warrior2.setName("战士-李四");

        GameCharacter warrior3 = registry.getPrototype("warrior");
        warrior3.setName("战士-王五");

        long endTime = System.currentTimeMillis();
        System.out.println("创建3个战士耗时: " + (endTime - startTime) + "ms\n");

        warrior1.displayInfo();

        // 场景2：验证深拷贝
        System.out.println("========== 场景2：验证深拷贝 ==========\n");

        GameCharacter mage1 = registry.getPrototype("mage");
        mage1.setName("法师-赵六");

        GameCharacter mage2 = registry.getPrototype("mage");
        mage2.setName("法师-孙七");

        // 给mage2添加新装备
        mage2.addEquipment(new Equipment("高级魔杖", 80, 0, 5));

        System.out.println("法师1的装备数量: " + mage1.getEquipments().size());
        System.out.println("法师2的装备数量: " + mage2.getEquipments().size());
        System.out.println("深拷贝成功：两个对象互不影响\n");

        // 场景3：浅拷贝的问题
        System.out.println("========== 场景3：浅拷贝的问题 ==========\n");

        GameCharacter assassin1 = registry.getPrototype("assassin");
        assassin1.setName("刺客-周八");

        GameCharacter assassin2 = assassin1.shallowClone();
        assassin2.setName("刺客-吴九");

        // 修改assassin2的装备会影响assassin1
        assassin2.addEquipment(new Equipment("暗影匕首", 100, 0, 10));

        System.out.println("刺客1的装备数量: " + assassin1.getEquipments().size());
        System.out.println("刺客2的装备数量: " + assassin2.getEquipments().size());
        System.out.println("浅拷贝问题：两个对象共享引用类型数据\n");

        // 场景4：性能对比
        System.out.println("========== 场景4：性能对比 ==========\n");

        // 直接创建
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            new GameCharacter("测试" + i, "战士");
        }
        endTime = System.currentTimeMillis();
        System.out.println("直接创建10个角色耗时: " + (endTime - startTime) + "ms");

        // 原型克隆
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            registry.getPrototype("warrior");
        }
        endTime = System.currentTimeMillis();
        System.out.println("克隆创建10个角色耗时: " + (endTime - startTime) + "ms");
        System.out.println("\n原型模式显著提高了创建效率！");
    }

    // 需要添加到GameCharacter类中
    public List<Equipment> getEquipments() {
        return equipments;
    }
}
```



我将继续详细讲解剩余的设计模式。

## 二、结构型模式

### 6. 适配器模式（Adapter Pattern）

**使用场景**：

* 系统需要复用现有类
* 接口不兼容的类需要一起工作
* 旧系统升级

**好处：**

- 提高类的复用性
- 增加类的透明性
- 灵活性好，可以随时替换适配器

**解决的问题：**

- 接口不兼容的类需要协同工作
- 使用第三方库但接口不匹配
- 老系统改造

**缺点：**

- 过多使用会使系统凌乱
- 增加系统复杂度
- 可能降低系统性能

**详细案例：第三方支付接口适配**

```java
/**
 * 统一的支付接口（目标接口）
 */
public interface UnifiedPayment {
    PaymentResponse pay(PaymentRequest request);
    RefundResponse refund(RefundRequest request);
    QueryResponse queryOrder(String orderId);
}

/**
 * 统一支付请求
 */
public class PaymentRequest {
    private String orderId;
    private BigDecimal amount;
    private String currency;
    private String description;
    private String returnUrl;
    private Map<String, String> extraParams;

    // 构造函数和getter/setter省略
    public PaymentRequest(String orderId, BigDecimal amount, String currency) {
        this.orderId = orderId;
        this.amount = amount;
        this.currency = currency;
        this.extraParams = new HashMap<>();
    }

    public String getOrderId() { return orderId; }
    public BigDecimal getAmount() { return amount; }
    public String getCurrency() { return currency; }
    public String getDescription() { return description; }
    public String getReturnUrl() { return returnUrl; }
    public Map<String, String> getExtraParams() { return extraParams; }

    public void setDescription(String description) { this.description = description; }
    public void setReturnUrl(String returnUrl) { this.returnUrl = returnUrl; }
    public void setExtraParam(String key, String value) { this.extraParams.put(key, value); }
}

/**
 * 统一支付响应
 */
public class PaymentResponse {
    private boolean success;
    private String transactionId;
    private String message;
    private String redirectUrl;

    public PaymentResponse(boolean success, String transactionId, String message) {
        this.success = success;
        this.transactionId = transactionId;
        this.message = message;
    }

    public boolean isSuccess() { return success; }
    public String getTransactionId() { return transactionId; }
    public String getMessage() { return message; }
    public String getRedirectUrl() { return redirectUrl; }
    public void setRedirectUrl(String redirectUrl) { this.redirectUrl = redirectUrl; }
}

/**
 * 退款请求
 */
public class RefundRequest {
    private String orderId;
    private String transactionId;
    private BigDecimal amount;
    private String reason;

    public RefundRequest(String orderId, String transactionId, BigDecimal amount) {
        this.orderId = orderId;
        this.transactionId = transactionId;
        this.amount = amount;
    }

    public String getOrderId() { return orderId; }
    public String getTransactionId() { return transactionId; }
    public BigDecimal getAmount() { return amount; }
    public String getReason() { return reason; }
    public void setReason(String reason) { this.reason = reason; }
}

/**
 * 退款响应
 */
public class RefundResponse {
    private boolean success;
    private String refundId;
    private String message;

    public RefundResponse(boolean success, String refundId, String message) {
        this.success = success;
        this.refundId = refundId;
        this.message = message;
    }

    public boolean isSuccess() { return success; }
    public String getRefundId() { return refundId; }
    public String getMessage() { return message; }
}

/**
 * 查询响应
 */
public class QueryResponse {
    private String orderId;
    private String status;
    private BigDecimal amount;
    private String transactionId;

    public QueryResponse(String orderId, String status, BigDecimal amount, String transactionId) {
        this.orderId = orderId;
        this.status = status;
        this.amount = amount;
        this.transactionId = transactionId;
    }

    public String getStatus() { return status; }
    public String getOrderId() { return orderId; }
    public BigDecimal getAmount() { return amount; }
    public String getTransactionId() { return transactionId; }
}

// ========== 被适配者：支付宝旧接口 ==========

/**
 * 支付宝旧版SDK（被适配者）
 */
public class AlipayLegacySDK {
    private String appId;
    private String privateKey;

    public AlipayLegacySDK(String appId, String privateKey) {
        this.appId = appId;
        this.privateKey = privateKey;
    }

    /**
     * 支付宝特有的支付方法
     */
    public AlipayTradeResult tradePay(AlipayTradeRequest tradeRequest) {
        System.out.println("调用支付宝旧版支付接口");
        System.out.println("  App ID: " + appId);
        System.out.println("  订单号: " + tradeRequest.getOutTradeNo());
        System.out.println("  金额: " + tradeRequest.getTotalAmount());
        System.out.println("  主题: " + tradeRequest.getSubject());

        // 模拟支付宝API调用
        AlipayTradeResult result = new AlipayTradeResult();
        result.setCode("10000");
        result.setMsg("Success");
        result.setTradeNo("2024" + System.currentTimeMillis());
        result.setOutTradeNo(tradeRequest.getOutTradeNo());

        return result;
    }

    /**
     * 支付宝特有的退款方法
     */
    public AlipayRefundResult tradeRefund(String outTradeNo, String refundAmount, String refundReason) {
        System.out.println("调用支付宝旧版退款接口");
        System.out.println("  订单号: " + outTradeNo);
        System.out.println("  退款金额: " + refundAmount);
        System.out.println("  退款原因: " + refundReason);

        AlipayRefundResult result = new AlipayRefundResult();
        result.setCode("10000");
        result.setMsg("Success");
        result.setRefundFee(refundAmount);

        return result;
    }

    /**
     * 支付宝特有的查询方法
     */
    public AlipayQueryResult tradeQuery(String outTradeNo) {
        System.out.println("调用支付宝旧版查询接口: " + outTradeNo);

        AlipayQueryResult result = new AlipayQueryResult();
        result.setCode("10000");
        result.setTradeStatus("TRADE_SUCCESS");
        result.setTotalAmount("99.99");
        result.setTradeNo("2024" + System.currentTimeMillis());

        return result;
    }
}

/**
 * 支付宝交易请求
 */
class AlipayTradeRequest {
    private String outTradeNo;
    private String totalAmount;
    private String subject;
    private String body;

    public String getOutTradeNo() { return outTradeNo; }
    public void setOutTradeNo(String outTradeNo) { this.outTradeNo = outTradeNo; }
    public String getTotalAmount() { return totalAmount; }
    public void setTotalAmount(String totalAmount) { this.totalAmount = totalAmount; }
    public String getSubject() { return subject; }
    public void setSubject(String subject) { this.subject = subject; }
    public String getBody() { return body; }
    public void setBody(String body) { this.body = body; }
}

/**
 * 支付宝交易结果
 */
class AlipayTradeResult {
    private String code;
    private String msg;
    private String tradeNo;
    private String outTradeNo;

    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public String getMsg() { return msg; }
    public void setMsg(String msg) { this.msg = msg; }
    public String getTradeNo() { return tradeNo; }
    public void setTradeNo(String tradeNo) { this.tradeNo = tradeNo; }
    public String getOutTradeNo() { return outTradeNo; }
    public void setOutTradeNo(String outTradeNo) { this.outTradeNo = outTradeNo; }
}

/**
 * 支付宝退款结果
 */
class AlipayRefundResult {
    private String code;
    private String msg;
    private String refundFee;

    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public String getMsg() { return msg; }
    public void setMsg(String msg) { this.msg = msg; }
    public String getRefundFee() { return refundFee; }
    public void setRefundFee(String refundFee) { this.refundFee = refundFee; }
}

/**
 * 支付宝查询结果
 */
class AlipayQueryResult {
    private String code;
    private String tradeStatus;
    private String totalAmount;
    private String tradeNo;

    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public String getTradeStatus() { return tradeStatus; }
    public void setTradeStatus(String tradeStatus) { this.tradeStatus = tradeStatus; }
    public String getTotalAmount() { return totalAmount; }
    public void setTotalAmount(String totalAmount) { this.totalAmount = totalAmount; }
    public String getTradeNo() { return tradeNo; }
    public void setTradeNo(String tradeNo) { this.tradeNo = tradeNo; }
}

// ========== 被适配者：微信支付SDK ==========

/**
 * 微信支付SDK（被适配者）
 */
public class WeChatPaySDK {
    private String appId;
    private String mchId;
    private String apiKey;

    public WeChatPaySDK(String appId, String mchId, String apiKey) {
        this.appId = appId;
        this.mchId = mchId;
        this.apiKey = apiKey;
    }

    /**
     * 微信特有的统一下单方法
     */
    public WeChatPayResponse unifiedOrder(WeChatPayRequest request) {
        System.out.println("调用微信支付统一下单接口");
        System.out.println("  App ID: " + appId);
        System.out.println("  商户号: " + mchId);
        System.out.println("  订单号: " + request.getOutTradeNo());
        System.out.println("  金额(分): " + request.getTotalFee());
        System.out.println("  描述: " + request.getBody());

        WeChatPayResponse response = new WeChatPayResponse();
        response.setReturnCode("SUCCESS");
        response.setResultCode("SUCCESS");
        response.setTransactionId("WX" + System.currentTimeMillis());
        response.setPrepayId("prepay_" + System.currentTimeMillis());

        return response;
    }

    /**
     * 微信特有的退款方法
     */
    public WeChatRefundResponse refundOrder(String outTradeNo, int totalFee, int refundFee, String refundDesc) {
        System.out.println("调用微信支付退款接口");
        System.out.println("  订单号: " + outTradeNo);
        System.out.println("  总金额(分): " + totalFee);
        System.out.println("  退款金额(分): " + refundFee);

        WeChatRefundResponse response = new WeChatRefundResponse();
        response.setReturnCode("SUCCESS");
        response.setResultCode("SUCCESS");
        response.setRefundId("REFUND" + System.currentTimeMillis());

        return response;
    }

    /**
     * 微信特有的查询方法
     */
    public WeChatQueryResponse orderQuery(String outTradeNo) {
        System.out.println("调用微信支付查询接口: " + outTradeNo);

        WeChatQueryResponse response = new WeChatQueryResponse();
        response.setReturnCode("SUCCESS");
        response.setTradeState("SUCCESS");
        response.setTotalFee(9999); // 单位：分
        response.setTransactionId("WX" + System.currentTimeMillis());

        return response;
    }
}

/**
 * 微信支付请求
 */
class WeChatPayRequest {
    private String outTradeNo;
    private int totalFee; // 单位：分
    private String body;
    private String notifyUrl;

    public String getOutTradeNo() { return outTradeNo; }
    public void setOutTradeNo(String outTradeNo) { this.outTradeNo = outTradeNo; }
    public int getTotalFee() { return totalFee; }
    public void setTotalFee(int totalFee) { this.totalFee = totalFee; }
    public String getBody() { return body; }
    public void setBody(String body) { this.body = body; }
    public String getNotifyUrl() { return notifyUrl; }
    public void setNotifyUrl(String notifyUrl) { this.notifyUrl = notifyUrl; }
}

/**
 * 微信支付响应
 */
class WeChatPayResponse {
    private String returnCode;
    private String resultCode;
    private String transactionId;
    private String prepayId;

    public String getReturnCode() { return returnCode; }
    public void setReturnCode(String returnCode) { this.returnCode = returnCode; }
    public String getResultCode() { return resultCode; }
    public void setResultCode(String resultCode) { this.resultCode = resultCode; }
    public String getTransactionId() { return transactionId; }
    public void setTransactionId(String transactionId) { this.transactionId = transactionId; }
    public String getPrepayId() { return prepayId; }
    public void setPrepayId(String prepayId) { this.prepayId = prepayId; }
}

/**
 * 微信退款响应
 */
class WeChatRefundResponse {
    private String returnCode;
    private String resultCode;
    private String refundId;

    public String getReturnCode() { return returnCode; }
    public void setReturnCode(String returnCode) { this.returnCode = returnCode; }
    public String getResultCode() { return resultCode; }
    public void setResultCode(String resultCode) { this.resultCode = resultCode; }
    public String getRefundId() { return refundId; }
    public void setRefundId(String refundId) { this.refundId = refundId; }
}

/**
 * 微信查询响应
 */
class WeChatQueryResponse {
    private String returnCode;
    private String tradeState;
    private int totalFee;
    private String transactionId;

    public String getReturnCode() { return returnCode; }
    public void setReturnCode(String returnCode) { this.returnCode = returnCode; }
    public String getTradeState() { return tradeState; }
    public void setTradeState(String tradeState) { this.tradeState = tradeState; }
    public int getTotalFee() { return totalFee; }
    public void setTotalFee(int totalFee) { this.totalFee = totalFee; }
    public String getTransactionId() { return transactionId; }
    public void setTransactionId(String transactionId) { this.transactionId = transactionId; }
}

// ========== 适配器 ==========

/**
 * 支付宝适配器
 */
public class AlipayAdapter implements UnifiedPayment {
    private AlipayLegacySDK alipaySDK;

    public AlipayAdapter(String appId, String privateKey) {
        this.alipaySDK = new AlipayLegacySDK(appId, privateKey);
    }

    @Override
    public PaymentResponse pay(PaymentRequest request) {
        System.out.println("\n========== 支付宝适配器：转换请求格式 ==========");

        // 将统一请求转换为支付宝格式
        AlipayTradeRequest alipayRequest = new AlipayTradeRequest();
        alipayRequest.setOutTradeNo(request.getOrderId());
        alipayRequest.setTotalAmount(request.getAmount().toString());
        alipayRequest.setSubject(request.getDescription() != null ? 
            request.getDescription() : "商品购买");

        // 调用支付宝SDK
        AlipayTradeResult alipayResult = alipaySDK.tradePay(alipayRequest);

        // 将支付宝结果转换为统一格式
        boolean success = "10000".equals(alipayResult.getCode());
        PaymentResponse response = new PaymentResponse(
            success,
            alipayResult.getTradeNo(),
            alipayResult.getMsg()
        );

        System.out.println("适配完成：" + (success ? "支付成功" : "支付失败"));
        System.out.println("=============================================\n");

        return response;
    }

    @Override
    public RefundResponse refund(RefundRequest request) {
        System.out.println("\n========== 支付宝适配器：退款 ==========");

        // 调用支付宝SDK
        AlipayRefundResult alipayResult = alipaySDK.tradeRefund(
            request.getOrderId(),
            request.getAmount().toString(),
            request.getReason()
        );

        // 转换结果
        boolean success = "10000".equals(alipayResult.getCode());
        RefundResponse response = new RefundResponse(
            success,
            request.getTransactionId(),
            alipayResult.getMsg()
        );

        System.out.println("=====================================\n");
        return response;
    }

    @Override
    public QueryResponse queryOrder(String orderId) {
        System.out.println("\n========== 支付宝适配器：查询订单 ==========");

        AlipayQueryResult alipayResult = alipaySDK.tradeQuery(orderId);

        QueryResponse response = new QueryResponse(
            orderId,
            alipayResult.getTradeStatus(),
            new BigDecimal(alipayResult.getTotalAmount()),
            alipayResult.getTradeNo()
        );

        System.out.println("========================================\n");
        return response;
    }
}

/**
 * 微信支付适配器
 */
public class WeChatPayAdapter implements UnifiedPayment {
    private WeChatPaySDK weChatSDK;

    public WeChatPayAdapter(String appId, String mchId, String apiKey) {
        this.weChatSDK = new WeChatPaySDK(appId, mchId, apiKey);
    }

    @Override
    public PaymentResponse pay(PaymentRequest request) {
        System.out.println("\n========== 微信支付适配器：转换请求格式 ==========");

        // 将统一请求转换为微信格式
        WeChatPayRequest weChatRequest = new WeChatPayRequest();
        weChatRequest.setOutTradeNo(request.getOrderId());
        // 微信金额单位是分，需要转换
        weChatRequest.setTotalFee(request.getAmount().multiply(new BigDecimal(100)).intValue());
        weChatRequest.setBody(request.getDescription() != null ? 
            request.getDescription() : "商品购买");
        weChatRequest.setNotifyUrl(request.getReturnUrl());

        // 调用微信SDK
        WeChatPayResponse weChatResult = weChatSDK.unifiedOrder(weChatRequest);

        // 将微信结果转换为统一格式
        boolean success = "SUCCESS".equals(weChatResult.getReturnCode()) && 
                         "SUCCESS".equals(weChatResult.getResultCode());
        PaymentResponse response = new PaymentResponse(
            success,
            weChatResult.getTransactionId(),
            success ? "支付成功" : "支付失败"
        );

        System.out.println("适配完成：" + (success ? "支付成功" : "支付失败"));
        System.out.println("==============================================\n");

        return response;
    }

    @Override
    public RefundResponse refund(RefundRequest request) {
        System.out.println("\n========== 微信支付适配器：退款 ==========");

        // 微信退款需要原订单金额，这里简化处理
        int totalFee = request.getAmount().multiply(new BigDecimal(100)).intValue();
        int refundFee = totalFee;

        WeChatRefundResponse weChatResult = weChatSDK.refundOrder(
            request.getOrderId(),
            totalFee,
            refundFee,
            request.getReason()
        );

        boolean success = "SUCCESS".equals(weChatResult.getReturnCode()) && 
                         "SUCCESS".equals(weChatResult.getResultCode());
        RefundResponse response = new RefundResponse(
            success,
            weChatResult.getRefundId(),
            success ? "退款成功" : "退款失败"
        );

        System.out.println("======================================\n");
        return response;
    }

    @Override
    public QueryResponse queryOrder(String orderId) {
        System.out.println("\n========== 微信支付适配器：查询订单 ==========");

        WeChatQueryResponse weChatResult = weChatSDK.orderQuery(orderId);

        // 微信金额单位是分，转换为元
        BigDecimal amount = new BigDecimal(weChatResult.getTotalFee())
            .divide(new BigDecimal(100));

        QueryResponse response = new QueryResponse(
            orderId,
            weChatResult.getTradeState(),
            amount,
            weChatResult.getTransactionId()
        );

        System.out.println("==========================================\n");
        return response;
    }
}

/**
 * 支付服务（客户端代码）
 */
public class PaymentService {
    private Map<String, UnifiedPayment> paymentChannels;

    public PaymentService() {
        this.paymentChannels = new HashMap<>();
        initializePaymentChannels();
    }

    private void initializePaymentChannels() {
        // 初始化支付宝
        paymentChannels.put("alipay", new AlipayAdapter(
            "alipay_app_id",
            "alipay_private_key"
        ));

        // 初始化微信支付
        paymentChannels.put("wechat", new WeChatPayAdapter(
            "wechat_app_id",
            "wechat_mch_id",
            "wechat_api_key"
        ));
    }

    /**
     * 统一支付接口
     */
    public PaymentResponse processPayment(String channel, PaymentRequest request) {
        UnifiedPayment payment = paymentChannels.get(channel);
        if (payment == null) {
            throw new IllegalArgumentException("不支持的支付渠道: " + channel);
        }

        return payment.pay(request);
    }

    /**
     * 统一退款接口
     */
    public RefundResponse processRefund(String channel, RefundRequest request) {
        UnifiedPayment payment = paymentChannels.get(channel);
        if (payment == null) {
            throw new IllegalArgumentException("不支持的支付渠道: " + channel);
        }

        return payment.refund(request);
    }

    /**
     * 统一查询接口
     */
    public QueryResponse queryOrder(String channel, String orderId) {
        UnifiedPayment payment = paymentChannels.get(channel);
        if (payment == null) {
            throw new IllegalArgumentException("不支持的支付渠道: " + channel);
        }

        return payment.queryOrder(orderId);
    }
}

/**
 * 使用示例
 */
public class AdapterDemo {
    public static void main(String[] args) {
        PaymentService paymentService = new PaymentService();

        // 场景1：使用支付宝支付
        System.out.println("========== 场景1：支付宝支付 ==========");
        PaymentRequest alipayRequest = new PaymentRequest(
            "ORDER001",
            new BigDecimal("99.99"),
            "CNY"
        );
        alipayRequest.setDescription("购买商品A");

        PaymentResponse alipayResponse = paymentService.processPayment("alipay", alipayRequest);
        System.out.println("支付结果: " + alipayResponse.getMessage());
        System.out.println("交易号: " + alipayResponse.getTransactionId());

        // 场景2：使用微信支付
        System.out.println("\n========== 场景2：微信支付 ==========");
        PaymentRequest wechatRequest = new PaymentRequest(
            "ORDER002",
            new BigDecimal("199.99"),
            "CNY"
        );
        wechatRequest.setDescription("购买商品B");
        wechatRequest.setReturnUrl("https://example.com/notify");

        PaymentResponse wechatResponse = paymentService.processPayment("wechat", wechatRequest);
        System.out.println("支付结果: " + wechatResponse.getMessage());
        System.out.println("交易号: " + wechatResponse.getTransactionId());

        // 场景3：退款
        System.out.println("\n========== 场景3：支付宝退款 ==========");
        RefundRequest refundRequest = new RefundRequest(
            "ORDER001",
            alipayResponse.getTransactionId(),
            new BigDecimal("99.99")
        );
        refundRequest.setReason("商品质量问题");

        RefundResponse refundResponse = paymentService.processRefund("alipay", refundRequest);
        System.out.println("退款结果: " + refundResponse.getMessage());

        // 场景4：查询订单
        System.out.println("\n========== 场景4：查询订单 ==========");
        QueryResponse queryResponse = paymentService.queryOrder("wechat", "ORDER002");
        System.out.println("订单状态: " + queryResponse.getStatus());
        System.out.println("订单金额: " + queryResponse.getAmount());

        // 场景5：切换支付方式的便利性
        System.out.println("\n========== 场景5：轻松切换支付方式 ==========");
        System.out.println("客户端代码无需修改，只需改变channel参数即可切换支付方式");
        System.out.println("这就是适配器模式的优势！");
    }
}
```

### 7. 桥接模式（Bridge Pattern）

**使用场景**：

* 抽象和实现需要独立变化
* 需要避免永久绑定
* 多个维度变化

**好处：**

- 分离抽象与实现
- 提高可扩展性
- 实现细节对客户端透明
- 符合开闭原则

**解决的问题：**

- 避免多层继承导致的类爆炸
- 抽象和实现需要独立变化
- 多维度变化的场景

**缺点：**

- 增加系统理解难度
- 需要正确识别独立变化的维度

**详细案例：消息发送系统**

```java
/**
 * 实现接口：消息发送方式
 */
public interface MessageSender {
    void send(String message, String receiver);
    boolean isAvailable();
    String getSenderType();
}

/**
 * 具体实现：邮件发送
 */
public class EmailSender implements MessageSender {
    private String smtpServer;
    private int port;
    private String username;
    private String password;

    public EmailSender(String smtpServer, int port, String username, String password) {
        this.smtpServer = smtpServer;
        this.port = port;
        this.username = username;
        this.password = password;
    }

    @Override
    public void send(String message, String receiver) {
        System.out.println("========== 邮件发送 ==========");
        System.out.println("SMTP服务器: " + smtpServer + ":" + port);
        System.out.println("发送者: " + username);
        System.out.println("接收者: " + receiver);
        System.out.println("内容: " + message);

        // 模拟邮件发送
        try {
            System.out.println("连接SMTP服务器...");
            Thread.sleep(100);
            System.out.println("认证成功...");
            System.out.println("邮件发送成功！");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("============================\n");
    }

    @Override
    public boolean isAvailable() {
        // 检查SMTP服务器是否可用
        return true;
    }

    @Override
    public String getSenderType() {
        return "Email";
    }
}

/**
 * 具体实现：短信发送
 */
public class SMSSender implements MessageSender {
    private String apiKey;
    private String apiSecret;
    private String signName;

    public SMSSender(String apiKey, String apiSecret, String signName) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.signName = signName;
    }

    @Override
    public void send(String message, String receiver) {
        System.out.println("========== 短信发送 ==========");
        System.out.println("API Key: " + apiKey);
        System.out.println("签名: " + signName);
        System.out.println("接收号码: " + receiver);
        System.out.println("内容: " + message);

        // 模拟短信发送
        System.out.println("调用短信网关API...");
        System.out.println("短信发送成功！");
        System.out.println("============================\n");
    }

    @Override
    public boolean isAvailable() {
        // 检查短信服务是否可用
        return true;
    }

    @Override
    public String getSenderType() {
        return "SMS";
    }
}

/**
 * 具体实现：微信发送
 */
public class WeChatSender implements MessageSender {
    private String appId;
    private String appSecret;

    public WeChatSender(String appId, String appSecret) {
        this.appId = appId;
        this.appSecret = appSecret;
    }

    @Override
    public void send(String message, String receiver) {
        System.out.println("========== 微信消息发送 ==========");
        System.out.println("App ID: " + appId);
        System.out.println("接收者OpenID: " + receiver);
        System.out.println("内容: " + message);

        // 模拟微信消息发送
        System.out.println("获取Access Token...");
        System.out.println("调用微信API...");
        System.out.println("微信消息发送成功！");
        System.out.println("===============================\n");
    }

    @Override
    public boolean isAvailable() {
        return true;
    }

    @Override
    public String getSenderType() {
        return "WeChat";
    }
}

/**
 * 具体实现：推送通知
 */
public class PushSender implements MessageSender {
    private String pushServiceUrl;
    private String appKey;

    public PushSender(String pushServiceUrl, String appKey) {
        this.pushServiceUrl = pushServiceUrl;
        this.appKey = appKey;
    }

    @Override
    public void send(String message, String receiver) {
        System.out.println("========== 推送通知 ==========");
        System.out.println("推送服务: " + pushServiceUrl);
        System.out.println("设备ID: " + receiver);
        System.out.println("内容: " + message);

        System.out.println("发送推送通知...");
        System.out.println("推送成功！");
        System.out.println("============================\n");
    }

    @Override
    public boolean isAvailable() {
        return true;
    }

    @Override
    public String getSenderType() {
        return "Push";
    }
}

// ========== 抽象层：消息类型 ==========

/**
 * 抽象类：消息
 */
public abstract class Message {
    protected MessageSender sender;
    protected String content;
    protected String receiver;
    protected LocalDateTime sendTime;

    public Message(MessageSender sender) {
        this.sender = sender;
        this.sendTime = LocalDateTime.now();
    }

    public void setContent(String content) {
        this.content = content;
    }

    public void setReceiver(String receiver) {
        this.receiver = receiver;
    }

    /**
     * 发送消息（模板方法）
     */
    public final void send() {
        if (!validateMessage()) {
            System.out.println("消息验证失败，发送中止！\n");
            return;
        }

        if (!sender.isAvailable()) {
            System.out.println("发送渠道不可用，发送中止！\n");
            return;
        }

        beforeSend();
        String formattedContent = formatContent();
        sender.send(formattedContent, receiver);
        afterSend();
        logMessage();
    }

    /**
     * 验证消息
     */
    protected boolean validateMessage() {
        return content != null && !content.isEmpty() && 
               receiver != null && !receiver.isEmpty();
    }

    /**
     * 格式化内容（由子类实现）
     */
    protected abstract String formatContent();

    /**
     * 发送前钩子
     */
    protected void beforeSend() {
        System.out.println("准备发送" + getMessageType() + "...");
    }

    /**
     * 发送后钩子
     */
    protected void afterSend() {
        System.out.println(getMessageType() + "发送完成！");
    }

    /**
     * 记录日志
     */
    protected void logMessage() {
        System.out.println("========== 消息日志 ==========");
        System.out.println("消息类型: " + getMessageType());
        System.out.println("发送方式: " + sender.getSenderType());
        System.out.println("接收者: " + receiver);
        System.out.println("发送时间: " + sendTime);
        System.out.println("============================\n");
    }

    /**
     * 获取消息类型
     */
    protected abstract String getMessageType();

    /**
     * 切换发送方式
     */
    public void setSender(MessageSender sender) {
        this.sender = sender;
    }
}

/**
 * 具体抽象：普通消息
 */
public class NormalMessage extends Message {
    public NormalMessage(MessageSender sender) {
        super(sender);
    }

    @Override
    protected String formatContent() {
        return "[普通消息] " + content;
    }

    @Override
    protected String getMessageType() {
        return "普通消息";
    }
}

/**
 * 具体抽象：紧急消息
 */
public class UrgentMessage extends Message {
    private int priority;

    public UrgentMessage(MessageSender sender, int priority) {
        super(sender);
        this.priority = priority;
    }

    @Override
    protected String formatContent() {
        return String.format("[紧急消息-P%d] ⚠️ %s ⚠️", priority, content);
    }

    @Override
    protected String getMessageType() {
        return "紧急消息(优先级" + priority + ")";
    }

    @Override
    protected void beforeSend() {
        super.beforeSend();
        System.out.println("⚠️ 这是一条紧急消息，优先级: " + priority);
    }
}

/**
 * 具体抽象：系统通知
 */
public class SystemNotification extends Message {
    private String systemName;

    public SystemNotification(MessageSender sender, String systemName) {
        super(sender);
        this.systemName = systemName;
    }

    @Override
    protected String formatContent() {
        return String.format("[%s系统通知] %s", systemName, content);
    }

    @Override
    protected String getMessageType() {
        return "系统通知";
    }

    @Override
    protected void beforeSend() {
        super.beforeSend();
        System.out.println("系统: " + systemName);
    }
}

/**
 * 具体抽象：营销消息
 */
public class MarketingMessage extends Message {
    private String campaignId;
    private String unsubscribeLink;

    public MarketingMessage(MessageSender sender, String campaignId) {
        super(sender);
        this.campaignId = campaignId;
        this.unsubscribeLink = "https://example.com/unsubscribe?id=" + campaignId;
    }

    @Override
    protected String formatContent() {
        return String.format("[营销活动-%s] %s\n\n退订链接: %s", 
            campaignId, content, unsubscribeLink);
    }

    @Override
    protected String getMessageType() {
        return "营销消息";
    }

    @Override
    protected boolean validateMessage() {
        // 营销消息需要额外验证
        if (!super.validateMessage()) {
            return false;
        }

        // 检查用户是否已退订（简化示例）
        System.out.println("检查用户订阅状态...");
        return true;
    }
}

/**
 * 使用示例
 */
public class BridgeDemo {
    public static void main(String[] args) {
        // 初始化各种发送方式
        MessageSender emailSender = new EmailSender(
            "smtp.example.com", 25, "noreply@example.com", "password"
        );

        MessageSender smsSender = new SMSSender(
            "api_key_123", "api_secret_456", "Example公司"
        );

        MessageSender wechatSender = new WeChatSender(
            "wx_app_id", "wx_app_secret"
        );

        MessageSender pushSender = new PushSender(
            "https://push.example.com", "app_key_123"
        );

        // 场景1：发送普通邮件消息
        System.out.println("========== 场景1：普通邮件 ==========\n");
        Message normalEmail = new NormalMessage(emailSender);
        normalEmail.setContent("您的订单已发货");
        normalEmail.setReceiver("customer@example.com");
        normalEmail.send();

        // 场景2：发送紧急短信
        System.out.println("========== 场景2：紧急短信 ==========\n");
        Message urgentSMS = new UrgentMessage(smsSender, 1);
        urgentSMS.setContent("系统检测到异常登录，请及时处理！");
        urgentSMS.setReceiver("13800138000");
        urgentSMS.send();

        // 场景3：发送系统通知（微信）
        System.out.println("========== 场景3：系统通知 ==========\n");
        Message systemNotify = new SystemNotification(wechatSender, "订单系统");
        systemNotify.setContent("您有新的订单待处理");
        systemNotify.setReceiver("openid_12345");
        systemNotify.send();

        // 场景4：发送营销消息（推送）
        System.out.println("========== 场景4：营销推送 ==========\n");
        Message marketing = new MarketingMessage(pushSender, "SPRING_SALE_2024");
        marketing.setContent("春季大促，全场5折起！");
        marketing.setReceiver("device_token_abc123");
        marketing.send();

        // 场景5：桥接模式的优势 - 动态切换发送方式
        System.out.println("========== 场景5：动态切换发送方式 ==========\n");
        Message flexibleMessage = new NormalMessage(emailSender);
        flexibleMessage.setContent("重要通知");
        flexibleMessage.setReceiver("user@example.com");

        System.out.println("--- 先通过邮件发送 ---");
        flexibleMessage.send();

        System.out.println("--- 切换为短信发送 ---");
        flexibleMessage.setSender(smsSender);
        flexibleMessage.setReceiver("13900139000");
        flexibleMessage.send();

        // 场景6：展示桥接模式避免类爆炸
        System.out.println("========== 场景6：桥接模式的价值 ==========");
        System.out.println("如果不使用桥接模式，需要的类数量:");
        System.out.println("  4种消息类型 × 4种发送方式 = 16个具体类");
        System.out.println("\n使用桥接模式后，需要的类数量:");
        System.out.println("  4种消息类型 + 4种发送方式 = 8个类");
        System.out.println("\n节省了50%的类！");
        System.out.println("更重要的是，新增消息类型或发送方式都很容易，符合开闭原则！");
    }
}
```



我将继续讲解剩余的结构型模式和行为型模式。

### 8. 组合模式（Composite Pattern）

**使用场景**：

* 表示对象的部分-整体层次结构
* 希望客户端忽略组合与单个对象的差异
* 树形菜单
* 文件系统

**好处：**

- 简化客户端代码（统一处理单个对象和组合对象）
- 易于扩展新类型的组件
- 符合开闭原则

**解决的问题：**

- 树形结构的对象管理
- 部分-整体层次结构
- 需要统一处理单个对象和组合对象

**缺点：**

- 使设计更加抽象
- 难以限制组合中的组件类型
- 可能违反依赖倒置原则

**详细案例：公司组织架构管理系统**

```java
/**
 * 员工信息
 */
public class EmployeeInfo {
    private String id;
    private String name;
    private String position;
    private BigDecimal salary;
    private String email;
    private LocalDate hireDate;

    public EmployeeInfo(String id, String name, String position, BigDecimal salary) {
        this.id = id;
        this.name = name;
        this.position = position;
        this.salary = salary;
        this.hireDate = LocalDate.now();
    }

    public String getId() { return id; }
    public String getName() { return name; }
    public String getPosition() { return position; }
    public BigDecimal getSalary() { return salary; }
    public String getEmail() { return email; }

    public void setEmail(String email) { this.email = email; }

    @Override
    public String toString() {
        return String.format("%s (%s) - %s - ¥%.2f", 
            name, id, position, salary);
    }
}

/**
 * 组件接口（部门和员工的共同接口）
 */
public abstract class OrganizationComponent {
    protected String name;

    public OrganizationComponent(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    // 组织结构操作
    public void add(OrganizationComponent component) {
        throw new UnsupportedOperationException("此操作不支持");
    }

    public void remove(OrganizationComponent component) {
        throw new UnsupportedOperationException("此操作不支持");
    }

    public OrganizationComponent getChild(int index) {
        throw new UnsupportedOperationException("此操作不支持");
    }

    // 业务操作
    public abstract void display(int depth);
    public abstract int getEmployeeCount();
    public abstract BigDecimal getTotalSalary();
    public abstract void raiseSalary(BigDecimal percentage);
    public abstract List<EmployeeInfo> getAllEmployees();
}

/**
 * 叶子节点：员工
 */
public class Employee extends OrganizationComponent {
    private EmployeeInfo info;

    public Employee(EmployeeInfo info) {
        super(info.getName());
        this.info = info;
    }

    @Override
    public void display(int depth) {
        String indent = "  ".repeat(depth);
        System.out.println(indent + "├─ 👤 " + info);
    }

    @Override
    public int getEmployeeCount() {
        return 1;
    }

    @Override
    public BigDecimal getTotalSalary() {
        return info.getSalary();
    }

    @Override
    public void raiseSalary(BigDecimal percentage) {
        BigDecimal currentSalary = info.getSalary();
        BigDecimal increase = currentSalary.multiply(percentage).divide(new BigDecimal(100));
        BigDecimal newSalary = currentSalary.add(increase);

        System.out.printf("  员工 %s 薪资调整: ¥%.2f → ¥%.2f (涨幅%.1f%%)\n",
            info.getName(), currentSalary, newSalary, percentage);

        // 实际应该更新info中的salary，这里简化处理
    }

    @Override
    public List<EmployeeInfo> getAllEmployees() {
        List<EmployeeInfo> list = new ArrayList<>();
        list.add(info);
        return list;
    }

    public EmployeeInfo getInfo() {
        return info;
    }
}

/**
 * 组合节点：部门
 */
public class Department extends OrganizationComponent {
    private List<OrganizationComponent> components;
    private Employee manager; // 部门经理
    private String description;

    public Department(String name, String description) {
        super(name);
        this.description = description;
        this.components = new ArrayList<>();
    }

    public void setManager(Employee manager) {
        this.manager = manager;
    }

    @Override
    public void add(OrganizationComponent component) {
        components.add(component);
    }

    @Override
    public void remove(OrganizationComponent component) {
        components.remove(component);
    }

    @Override
    public OrganizationComponent getChild(int index) {
        return components.get(index);
    }

    @Override
    public void display(int depth) {
        String indent = "  ".repeat(depth);
        System.out.println(indent + "📁 " + name + " (" + description + ")");

        if (manager != null) {
            System.out.println(indent + "  负责人: " + manager.getInfo());
        }

        System.out.println(indent + "  员工数: " + getEmployeeCount() + 
                         " | 总薪资: ¥" + getTotalSalary());

        // 递归显示子组件
        for (OrganizationComponent component : components) {
            component.display(depth + 1);
        }
    }

    @Override
    public int getEmployeeCount() {
        int count = 0;
        for (OrganizationComponent component : components) {
            count += component.getEmployeeCount();
        }
        return count;
    }

    @Override
    public BigDecimal getTotalSalary() {
        BigDecimal total = BigDecimal.ZERO;
        for (OrganizationComponent component : components) {
            total = total.add(component.getTotalSalary());
        }
        return total;
    }

    @Override
    public void raiseSalary(BigDecimal percentage) {
        System.out.println("\n对 " + name + " 部门进行薪资调整 (+" + percentage + "%):");
        for (OrganizationComponent component : components) {
            component.raiseSalary(percentage);
        }
    }

    @Override
    public List<EmployeeInfo> getAllEmployees() {
        List<EmployeeInfo> allEmployees = new ArrayList<>();
        for (OrganizationComponent component : components) {
            allEmployees.addAll(component.getAllEmployees());
        }
        return allEmployees;
    }

    /**
     * 查找员工
     */
    public Employee findEmployee(String employeeId) {
        for (OrganizationComponent component : components) {
            if (component instanceof Employee) {
                Employee emp = (Employee) component;
                if (emp.getInfo().getId().equals(employeeId)) {
                    return emp;
                }
            } else if (component instanceof Department) {
                Employee found = ((Department) component).findEmployee(employeeId);
                if (found != null) {
                    return found;
                }
            }
        }
        return null;
    }

    /**
     * 统计部门信息
     */
    public DepartmentStatistics getStatistics() {
        return new DepartmentStatistics(this);
    }
}

/**
 * 部门统计信息
 */
public class DepartmentStatistics {
    private String departmentName;
    private int totalEmployees;
    private BigDecimal totalSalary;
    private BigDecimal averageSalary;
    private BigDecimal maxSalary;
    private BigDecimal minSalary;

    public DepartmentStatistics(Department department) {
        this.departmentName = department.getName();
        this.totalEmployees = department.getEmployeeCount();
        this.totalSalary = department.getTotalSalary();

        List<EmployeeInfo> employees = department.getAllEmployees();
        if (!employees.isEmpty()) {
            this.averageSalary = totalSalary.divide(
                new BigDecimal(totalEmployees), 2, RoundingMode.HALF_UP);

            this.maxSalary = employees.stream()
                .map(EmployeeInfo::getSalary)
                .max(BigDecimal::compareTo)
                .orElse(BigDecimal.ZERO);

            this.minSalary = employees.stream()
                .map(EmployeeInfo::getSalary)
                .min(BigDecimal::compareTo)
                .orElse(BigDecimal.ZERO);
        }
    }

    public void display() {
        System.out.println("========== " + departmentName + " 统计信息 ==========");
        System.out.println("总人数: " + totalEmployees);
        System.out.printf("总薪资: ¥%.2f\n", totalSalary);
        System.out.printf("平均薪资: ¥%.2f\n", averageSalary);
        System.out.printf("最高薪资: ¥%.2f\n", maxSalary);
        System.out.printf("最低薪资: ¥%.2f\n", minSalary);
        System.out.println("===========================================\n");
    }
}

/**
 * 使用示例
 */
public class CompositeDemo {
    public static void main(String[] args) {
        // 构建公司组织架构
        System.out.println("========== 构建公司组织架构 ==========\n");

        // 创建根节点 - 公司
        Department company = new Department("科技有限公司", "总部");

        // CEO
        Employee ceo = new Employee(new EmployeeInfo(
            "E001", "张三", "CEO", new BigDecimal("50000")));
        company.add(ceo);
        company.setManager(ceo);

        // 创建技术部
        Department techDept = new Department("技术部", "负责产品研发");
        Employee techManager = new Employee(new EmployeeInfo(
            "E002", "李四", "技术总监", new BigDecimal("30000")));
        techDept.setManager(techManager);
        techDept.add(techManager);

        // 技术部 - 前端组
        Department frontendTeam = new Department("前端组", "前端开发");
        frontendTeam.add(new Employee(new EmployeeInfo(
            "E003", "王五", "前端组长", new BigDecimal("20000"))));
        frontendTeam.add(new Employee(new EmployeeInfo(
            "E004", "赵六", "高级前端工程师", new BigDecimal("18000"))));
        frontendTeam.add(new Employee(new EmployeeInfo(
            "E005", "孙七", "前端工程师", new BigDecimal("12000"))));
        frontendTeam.add(new Employee(new EmployeeInfo(
            "E006", "周八", "前端工程师", new BigDecimal("12000"))));

        // 技术部 - 后端组
        Department backendTeam = new Department("后端组", "后端开发");
        backendTeam.add(new Employee(new EmployeeInfo(
            "E007", "吴九", "后端组长", new BigDecimal("22000"))));
        backendTeam.add(new Employee(new EmployeeInfo(
            "E008", "郑十", "高级后端工程师", new BigDecimal("19000"))));
        backendTeam.add(new Employee(new EmployeeInfo(
            "E009", "钱十一", "后端工程师", new BigDecimal("13000"))));
        backendTeam.add(new Employee(new EmployeeInfo(
            "E010", "冯十二", "后端工程师", new BigDecimal("13000"))));
        backendTeam.add(new Employee(new EmployeeInfo(
            "E011", "陈十三", "初级后端工程师", new BigDecimal("10000"))));

        // 技术部 - 测试组
        Department qaTeam = new Department("测试组", "质量保证");
        qaTeam.add(new Employee(new EmployeeInfo(
            "E012", "楚十四", "测试组长", new BigDecimal("18000"))));
        qaTeam.add(new Employee(new EmployeeInfo(
            "E013", "魏十五", "测试工程师", new BigDecimal("11000"))));
        qaTeam.add(new Employee(new EmployeeInfo(
            "E014", "蒋十六", "测试工程师", new BigDecimal("11000"))));

        // 将小组加入技术部
        techDept.add(frontendTeam);
        techDept.add(backendTeam);
        techDept.add(qaTeam);

        // 创建销售部
        Department salesDept = new Department("销售部", "市场销售");
        Employee salesManager = new Employee(new EmployeeInfo(
            "E015", "沈十七", "销售总监", new BigDecimal("28000")));
        salesDept.setManager(salesManager);
        salesDept.add(salesManager);
        salesDept.add(new Employee(new EmployeeInfo(
            "E016", "韩十八", "销售经理", new BigDecimal("16000"))));
        salesDept.add(new Employee(new EmployeeInfo(
            "E017", "杨十九", "销售代表", new BigDecimal("9000"))));
        salesDept.add(new Employee(new EmployeeInfo(
            "E018", "朱二十", "销售代表", new BigDecimal("9000"))));
        salesDept.add(new Employee(new EmployeeInfo(
            "E019", "秦二一", "销售代表", new BigDecimal("8000"))));

        // 创建人事部
        Department hrDept = new Department("人事部", "人力资源");
        Employee hrManager = new Employee(new EmployeeInfo(
            "E020", "尤二二", "人事总监", new BigDecimal("25000")));
        hrDept.setManager(hrManager);
        hrDept.add(hrManager);
        hrDept.add(new Employee(new EmployeeInfo(
            "E021", "许二三", "招聘专员", new BigDecimal("10000"))));
        hrDept.add(new Employee(new EmployeeInfo(
            "E022", "何二四", "薪酬专员", new BigDecimal("10000"))));

        // 将各部门加入公司
        company.add(techDept);
        company.add(salesDept);
        company.add(hrDept);

        // 场景1：显示完整组织架构
        System.out.println("========== 场景1：显示组织架构 ==========\n");
        company.display(0);

        // 场景2：统计信息
        System.out.println("\n========== 场景2：部门统计 ==========\n");

        // 整个公司统计
        DepartmentStatistics companyStats = company.getStatistics();
        companyStats.display();

        // 技术部统计
        DepartmentStatistics techStats = techDept.getStatistics();
        techStats.display();

        // 前端组统计
        DepartmentStatistics frontendStats = frontendTeam.getStatistics();
        frontendStats.display();

        // 场景3：给特定部门涨薪
        System.out.println("========== 场景3：部门涨薪 ==========");

        // 给技术部涨薪10%
        techDept.raiseSalary(new BigDecimal("10"));

        // 给销售部涨薪15%
        salesDept.raiseSalary(new BigDecimal("15"));

        // 场景4：查找员工
        System.out.println("\n========== 场景4：查找员工 ==========\n");
        Employee found = company.findEmployee("E009");
        if (found != null) {
            System.out.println("找到员工: " + found.getInfo());
        }

        // 场景5：重组架构
        System.out.println("\n========== 场景5：组织架构调整 ==========\n");

        // 将测试组从技术部移到独立的质量部
        Department qaDept = new Department("质量部", "独立质量保证");
        techDept.remove(qaTeam);
        qaDept.add(qaTeam);
        qaDept.add(new Employee(new EmployeeInfo(
            "E023", "施二五", "质量总监", new BigDecimal("26000"))));
        company.add(qaDept);

        System.out.println("调整后的组织架构:\n");
        company.display(0);

        // 场景6：组合模式的优势
        System.out.println("\n========== 场景6：组合模式的优势 ==========");
        System.out.println("1. 统一接口: 可以用相同的方式处理员工和部门");
        System.out.println("2. 递归操作: 自动处理整个树形结构（如涨薪、统计）");
        System.out.println("3. 灵活组合: 可以随意调整组织架构");
        System.out.println("4. 易于扩展: 添加新的组件类型很容易");

        // 场景7：获取所有员工信息
        System.out.println("\n========== 场景7：导出员工名单 ==========\n");
        List<EmployeeInfo> allEmployees = company.getAllEmployees();
        System.out.println("公司总员工数: " + allEmployees.size());
        System.out.println("\n完整员工名单:");
        allEmployees.forEach(emp -> System.out.println("  " + emp));
    }
}
```

### 9. 装饰器模式（Decorator Pattern）

**使用场景**：

* 动态添加职责
* 需要扩展功能但不想使用继承
* I/O流处理

**好处：**

- 比继承更灵活
- 可以动态添加或撤销功能
- 遵循开闭原则
- 可以组合多个装饰器

**解决的问题：**

- 需要动态给对象添加功能
- 不想使用大量子类
- 需要不同功能的组合

**缺点：**

- 产生很多小对象
- 多层装饰会使调试复杂
- 装饰顺序可能影响结果

**详细案例：咖啡订单系统**

```java
/**
 * 组件接口：饮料
 */
public abstract class Beverage {
    protected String description = "未知饮料";
    protected Size size = Size.MEDIUM;

    public enum Size {
        SMALL("小杯", 0.8),
        MEDIUM("中杯", 1.0),
        LARGE("大杯", 1.2),
        EXTRA_LARGE("超大杯", 1.5);

        private String name;
        private double multiplier;

        Size(String name, double multiplier) {
            this.name = name;
            this.multiplier = multiplier;
        }

        public String getName() { return name; }
        public double getMultiplier() { return multiplier; }
    }

    public String getDescription() {
        return description;
    }

    public void setSize(Size size) {
        this.size = size;
    }

    public Size getSize() {
        return size;
    }

    /**
     * 计算价格（抽象方法）
     */
    public abstract double cost();

    /**
     * 获取完整描述
     */
    public String getFullDescription() {
        return String.format("%s %s - ¥%.2f", 
            size.getName(), getDescription(), cost());
    }
}

/**
 * 具体组件：浓缩咖啡
 */
public class Espresso extends Beverage {
    public Espresso() {
        description = "浓缩咖啡";
    }

    @Override
    public double cost() {
        double basePrice = 15.0;
        return basePrice * size.getMultiplier();
    }
}

/**
 * 具体组件：深度烘焙咖啡
 */
public class DarkRoast extends Beverage {
    public DarkRoast() {
        description = "深度烘焙咖啡";
    }

    @Override
    public double cost() {
        double basePrice = 12.0;
        return basePrice * size.getMultiplier();
    }
}

/**
 * 具体组件：美式咖啡
 */
public class HouseBlend extends Beverage {
    public HouseBlend() {
        description = "美式咖啡";
    }

    @Override
    public double cost() {
        double basePrice = 10.0;
        return basePrice * size.getMultiplier();
    }
}

/**
 * 具体组件：拿铁
 */
public class Latte extends Beverage {
    public Latte() {
        description = "拿铁";
    }

    @Override
    public double cost() {
        double basePrice = 18.0;
        return basePrice * size.getMultiplier();
    }
}

/**
 * 具体组件：卡布奇诺
 */
public class Cappuccino extends Beverage {
    public Cappuccino() {
        description = "卡布奇诺";
    }

    @Override
    public double cost() {
        double basePrice = 18.0;
        return basePrice * size.getMultiplier();
    }
}

/**
 * 装饰器抽象类
 */
public abstract class CondimentDecorator extends Beverage {
    protected Beverage beverage;

    public CondimentDecorator(Beverage beverage) {
        this.beverage = beverage;
        this.size = beverage.getSize();
    }

    @Override
    public abstract String getDescription();

    @Override
    public void setSize(Size size) {
        beverage.setSize(size);
        this.size = size;
    }
}

/**
 * 具体装饰器：牛奶
 */
public class Milk extends CondimentDecorator {
    public Milk(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 牛奶";
    }

    @Override
    public double cost() {
        double condimentCost = 3.0;
        return beverage.cost() + condimentCost * size.getMultiplier();
    }
}

/**
 * 具体装饰器：豆奶
 */
public class Soy extends CondimentDecorator {
    public Soy(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 豆奶";
    }

    @Override
    public double cost() {
        double condimentCost = 4.0;
        return beverage.cost() + condimentCost * size.getMultiplier();
    }
}

/**
 * 具体装饰器：摩卡
 */
public class Mocha extends CondimentDecorator {
    public Mocha(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 摩卡";
    }

    @Override
    public double cost() {
        double condimentCost = 5.0;
        return beverage.cost() + condimentCost * size.getMultiplier();
    }
}

/**
 * 具体装饰器：奶泡
 */
public class Whip extends CondimentDecorator {
    public Whip(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 奶泡";
    }

    @Override
    public double cost() {
        double condimentCost = 2.0;
        return beverage.cost() + condimentCost * size.getMultiplier();
    }
}

/**
 * 具体装饰器：焦糖
 */
public class Caramel extends CondimentDecorator {
    public Caramel(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 焦糖";
    }

    @Override
    public double cost() {
        double condimentCost = 4.5;
        return beverage.cost() + condimentCost * size.getMultiplier();
    }
}

/**
 * 具体装饰器：香草糖浆
 */
public class Vanilla extends CondimentDecorator {
    public Vanilla(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 香草糖浆";
    }

    @Override
    public double cost() {
        double condimentCost = 3.5;
        return beverage.cost() + condimentCost * size.getMultiplier();
    }
}

/**
 * 具体装饰器：榛果糖浆
 */
public class Hazelnut extends CondimentDecorator {
    public Hazelnut(Beverage beverage) {
        super(beverage);
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 榛果糖浆";
    }

    @Override
    public double cost() {
        double condimentCost = 3.5;
        return beverage.cost() + condimentCost * size.getMultiplier();
    }
}

/**
 * 订单类
 */
public class Order {
    private List<Beverage> beverages;
    private String customerName;
    private LocalDateTime orderTime;
    private String orderId;

    public Order(String customerName) {
        this.customerName = customerName;
        this.beverages = new ArrayList<>();
        this.orderTime = LocalDateTime.now();
        this.orderId = "ORD" + System.currentTimeMillis();
    }

    public void addBeverage(Beverage beverage) {
        beverages.add(beverage);
    }

    public double getTotalCost() {
        return beverages.stream()
            .mapToDouble(Beverage::cost)
            .sum();
    }

    public void printReceipt() {
        System.out.println("\n========================================");
        System.out.println("           咖啡店订单");
        System.out.println("========================================");
        System.out.println("订单号: " + orderId);
        System.out.println("顾客: " + customerName);
        System.out.println("时间: " + orderTime.format(
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
        System.out.println("----------------------------------------");

        int itemNumber = 1;
        for (Beverage beverage : beverages) {
            System.out.printf("%d. %s\n", itemNumber++, 
                beverage.getFullDescription());
        }

        System.out.println("----------------------------------------");
        System.out.printf("总计: ¥%.2f\n", getTotalCost());
        System.out.println("========================================\n");
    }
}

/**
 * 使用示例
 */
public class DecoratorDemo {
    public static void main(String[] args) {
        System.out.println("========== 欢迎来到星巴克咖啡店 ==========\n");

        Order order = new Order("张三");

        // 场景1：简单订单 - 中杯美式咖啡
        System.out.println("场景1：点一杯中杯美式咖啡");
        Beverage beverage1 = new HouseBlend();
        System.out.println(beverage1.getFullDescription());
        order.addBeverage(beverage1);

        // 场景2：加一份调料 - 浓缩咖啡 + 摩卡
        System.out.println("\n场景2：浓缩咖啡 + 摩卡");
        Beverage beverage2 = new Espresso();
        beverage2 = new Mocha(beverage2);
        System.out.println(beverage2.getFullDescription());
        order.addBeverage(beverage2);

        // 场景3：多重装饰 - 深度烘焙 + 双份摩卡 + 奶泡
        System.out.println("\n场景3：深度烘焙 + 双份摩卡 + 奶泡");
        Beverage beverage3 = new DarkRoast();
        beverage3 = new Mocha(beverage3);
        beverage3 = new Mocha(beverage3); // 双份摩卡
        beverage3 = new Whip(beverage3);
        System.out.println(beverage3.getFullDescription());
        order.addBeverage(beverage3);

        // 场景4：复杂定制 - 大杯拿铁 + 豆奶 + 焦糖 + 香草 + 奶泡
        System.out.println("\n场景4：大杯焦糖香草豆奶拿铁（加奶泡）");
        Beverage beverage4 = new Latte();
        beverage4.setSize(Beverage.Size.LARGE);
        beverage4 = new Soy(beverage4);
        beverage4 = new Caramel(beverage4);
        beverage4 = new Vanilla(beverage4);
        beverage4 = new Whip(beverage4);
        System.out.println(beverage4.getFullDescription());
        order.addBeverage(beverage4);

        // 场景5：小杯卡布奇诺 + 榛果 + 牛奶
        System.out.println("\n场景5：小杯榛果卡布奇诺");
        Beverage beverage5 = new Cappuccino();
        beverage5.setSize(Beverage.Size.SMALL);
        beverage5 = new Hazelnut(beverage5);
        beverage5 = new Milk(beverage5);
        System.out.println(beverage5.getFullDescription());
        order.addBeverage(beverage5);

        // 场景6：超大杯美式 + 三份浓缩
        System.out.println("\n场景6：超大杯三倍浓缩美式（提神专用）");
        Beverage beverage6 = new HouseBlend();
        beverage6.setSize(Beverage.Size.EXTRA_LARGE);
        // 通过装饰器模拟添加浓缩（这里用摩卡代替演示装饰器叠加）
        beverage6 = new Mocha(beverage6);
        beverage6 = new Mocha(beverage6);
        beverage6 = new Mocha(beverage6);
        System.out.println(beverage6.getFullDescription());
        order.addBeverage(beverage6);

        // 打印订单
        order.printReceipt();

        // 场景7：展示装饰器模式的优势
        System.out.println("========== 装饰器模式的优势 ==========");
        System.out.println("1. 动态组合: 可以任意组合不同的调料");
        System.out.println("2. 灵活扩展: 添加新调料无需修改现有代码");
        System.out.println("3. 避免类爆炸: 不使用装饰器需要创建大量子类");
        System.out.println("   例如: 摩卡拿铁、焦糖拿铁、双份摩卡拿铁...");
        System.out.println("   5种饮料 × 8种调料的组合 = 数千种可能");
        System.out.println("4. 符合开闭原则: 对扩展开放，对修改关闭");

        // 场景8：对比不使用装饰器的情况
        System.out.println("\n========== 如果不使用装饰器模式 ==========");
        System.out.println("需要创建的类:");
        System.out.println("  - Latte");
        System.out.println("  - LatteWithMilk");
        System.out.println("  - LatteWithSoy");
        System.out.println("  - LatteWithMilkAndMocha");
        System.out.println("  - LatteWithSoyAndCaramel");
        System.out.println("  - LatteWithSoyAndCaramelAndVanilla");
        System.out.println("  - ... 数百个类 ...");
        System.out.println("\n使用装饰器模式:");
        System.out.println("  - 5个饮料基类");
        System.out.println("  - 8个装饰器类");
        System.out.println("  - 总共13个类，支持无限组合！");

        // 场景9：运行时动态改变
        System.out.println("\n========== 场景9：动态修改订单 ==========");
        Beverage customBeverage = new Espresso();
        System.out.println("初始: " + customBeverage.getFullDescription());

        customBeverage = new Milk(customBeverage);
        System.out.println("加牛奶: " + customBeverage.getFullDescription());

        customBeverage = new Mocha(customBeverage);
        System.out.println("再加摩卡: " + customBeverage.getFullDescription());

        customBeverage.setSize(Beverage.Size.LARGE);
        System.out.println("改成大杯: " + customBeverage.getFullDescription());
    }
}
```



我将继续讲解剩余的结构型模式和行为型模式。

### 10. 外观模式（Facade Pattern）

**使用场景**：

* 复杂子系统需要简单接口
* 分层架构
* 减少系统依赖

**好处：**

- 简化复杂系统的使用
- 降低客户端与子系统的耦合度
- 更好的分层设计
- 提供统一的高层接口

**解决的问题：**

- 系统过于复杂
- 需要简化多个子系统的交互
- 降低系统依赖

**缺点：**

- 可能成为上帝对象（God Object）
- 不符合开闭原则（增加新子系统需修改外观类）

**详细案例：智能家居控制系统**

```java
/**
 * 子系统1：照明系统
 */
public class LightingSystem {
    private Map<String, Boolean> lights;
    private int brightness;

    public LightingSystem() {
        this.lights = new HashMap<>();
        lights.put("客厅", false);
        lights.put("卧室", false);
        lights.put("厨房", false);
        lights.put("卫生间", false);
        this.brightness = 100;
    }

    public void turnOnLight(String room) {
        lights.put(room, true);
        System.out.println("  💡 " + room + "灯光已开启");
    }

    public void turnOffLight(String room) {
        lights.put(room, false);
        System.out.println("  💡 " + room + "灯光已关闭");
    }

    public void turnOnAllLights() {
        System.out.println("  💡 开启所有灯光");
        lights.keySet().forEach(room -> lights.put(room, true));
    }

    public void turnOffAllLights() {
        System.out.println("  💡 关闭所有灯光");
        lights.keySet().forEach(room -> lights.put(room, false));
    }

    public void setBrightness(int level) {
        this.brightness = Math.min(100, Math.max(0, level));
        System.out.println("  💡 调整亮度至 " + this.brightness + "%");
    }

    public void dimLights() {
        setBrightness(30);
        System.out.println("  💡 调暗灯光（适合观影）");
    }
}

/**
 * 子系统2：空调系统
 */
public class AirConditioningSystem {
    private boolean isOn;
    private int temperature;
    private String mode;

    public AirConditioningSystem() {
        this.isOn = false;
        this.temperature = 26;
        this.mode = "制冷";
    }

    public void turnOn() {
        isOn = true;
        System.out.println("  ❄️ 空调已开启");
    }

    public void turnOff() {
        isOn = false;
        System.out.println("  ❄️ 空调已关闭");
    }

    public void setTemperature(int temp) {
        if (!isOn) {
            turnOn();
        }
        this.temperature = Math.min(30, Math.max(16, temp));
        System.out.println("  ❄️ 温度设置为 " + this.temperature + "°C");
    }

    public void setMode(String mode) {
        if (!isOn) {
            turnOn();
        }
        this.mode = mode;
        System.out.println("  ❄️ 模式切换为: " + mode);
    }

    public void setComfortMode() {
        turnOn();
        setTemperature(24);
        setMode("自动");
        System.out.println("  ❄️ 舒适模式已启动");
    }
}

/**
 * 子系统3：音响系统
 */
public class AudioSystem {
    private boolean isOn;
    private int volume;
    private String source;
    private String currentSong;

    public AudioSystem() {
        this.isOn = false;
        this.volume = 50;
        this.source = "蓝牙";
    }

    public void turnOn() {
        isOn = true;
        System.out.println("  🔊 音响已开启");
    }

    public void turnOff() {
        isOn = false;
        System.out.println("  🔊 音响已关闭");
    }

    public void setVolume(int level) {
        if (!isOn) {
            turnOn();
        }
        this.volume = Math.min(100, Math.max(0, level));
        System.out.println("  🔊 音量设置为 " + this.volume);
    }

    public void setSource(String source) {
        if (!isOn) {
            turnOn();
        }
        this.source = source;
        System.out.println("  🔊 音源切换为: " + source);
    }

    public void playMusic(String song) {
        if (!isOn) {
            turnOn();
        }
        this.currentSong = song;
        System.out.println("  🔊 正在播放: " + song);
    }

    public void stopMusic() {
        System.out.println("  🔊 停止播放");
        this.currentSong = null;
    }
}

/**
 * 子系统4：窗帘系统
 */
public class CurtainSystem {
    private int openPercentage;

    public CurtainSystem() {
        this.openPercentage = 100;
    }

    public void open() {
        openPercentage = 100;
        System.out.println("  🪟 窗帘已完全打开");
    }

    public void close() {
        openPercentage = 0;
        System.out.println("  🪟 窗帘已完全关闭");
    }

    public void setPosition(int percentage) {
        this.openPercentage = Math.min(100, Math.max(0, percentage));
        System.out.println("  🪟 窗帘开启至 " + this.openPercentage + "%");
    }
}

/**
 * 子系统5：电视系统
 */
public class TVSystem {
    private boolean isOn;
    private int channel;
    private int volume;

    public TVSystem() {
        this.isOn = false;
        this.channel = 1;
        this.volume = 30;
    }

    public void turnOn() {
        isOn = true;
        System.out.println("  📺 电视已开启");
    }

    public void turnOff() {
        isOn = false;
        System.out.println("  📺 电视已关闭");
    }

    public void setChannel(int channel) {
        if (!isOn) {
            turnOn();
        }
        this.channel = channel;
        System.out.println("  📺 切换到频道 " + channel);
    }

    public void setVolume(int volume) {
        if (!isOn) {
            turnOn();
        }
        this.volume = Math.min(100, Math.max(0, volume));
        System.out.println("  📺 电视音量设置为 " + this.volume);
    }

    public void launchApp(String app) {
        if (!isOn) {
            turnOn();
        }
        System.out.println("  📺 启动应用: " + app);
    }
}

/**
 * 子系统6：安防系统
 */
public class SecuritySystem {
    private boolean isArmed;
    private List<String> cameras;
    private boolean doorLocked;

    public SecuritySystem() {
        this.isArmed = false;
        this.cameras = Arrays.asList("前门", "后门", "客厅", "车库");
        this.doorLocked = false;
    }

    public void arm() {
        isArmed = true;
        System.out.println("  🔒 安防系统已启动");
    }

    public void disarm() {
        isArmed = false;
        System.out.println("  🔒 安防系统已解除");
    }

    public void lockDoors() {
        doorLocked = true;
        System.out.println("  🔒 所有门已上锁");
    }

    public void unlockDoors() {
        doorLocked = false;
        System.out.println("  🔒 所有门已解锁");
    }

    public void startRecording() {
        System.out.println("  🔒 摄像头开始录像");
        cameras.forEach(cam -> 
            System.out.println("    - " + cam + "摄像头录像中"));
    }

    public void stopRecording() {
        System.out.println("  🔒 摄像头停止录像");
    }
}

/**
 * 外观类：智能家居控制器
 */
public class SmartHomeFacade {
    private LightingSystem lightingSystem;
    private AirConditioningSystem acSystem;
    private AudioSystem audioSystem;
    private CurtainSystem curtainSystem;
    private TVSystem tvSystem;
    private SecuritySystem securitySystem;

    public SmartHomeFacade() {
        this.lightingSystem = new LightingSystem();
        this.acSystem = new AirConditioningSystem();
        this.audioSystem = new AudioSystem();
        this.curtainSystem = new CurtainSystem();
        this.tvSystem = new TVSystem();
        this.securitySystem = new SecuritySystem();
    }

    /**
     * 场景1：回家模式
     */
    public void arriveHome() {
        System.out.println("\n========== 🏠 回家模式启动 ==========");

        // 解除安防
        securitySystem.disarm();
        securitySystem.unlockDoors();

        // 开灯
        lightingSystem.turnOnLight("客厅");
        lightingSystem.turnOnLight("卧室");
        lightingSystem.setBrightness(80);

        // 空调
        acSystem.setComfortMode();

        // 打开窗帘
        curtainSystem.setPosition(50);

        System.out.println("欢迎回家！环境已就绪。");
        System.out.println("=====================================\n");
    }

    /**
     * 场景2：离家模式
     */
    public void leaveHome() {
        System.out.println("\n========== 🚪 离家模式启动 ==========");

        // 关闭所有灯光
        lightingSystem.turnOffAllLights();

        // 关闭空调
        acSystem.turnOff();

        // 关闭音响
        audioSystem.turnOff();

        // 关闭电视
        tvSystem.turnOff();

        // 关闭窗帘
        curtainSystem.close();

        // 启动安防
        securitySystem.lockDoors();
        securitySystem.arm();
        securitySystem.startRecording();

        System.out.println("家已安全锁定，祝您旅途愉快！");
        System.out.println("=====================================\n");
    }

    /**
     * 场景3：睡眠模式
     */
    public void sleepMode() {
        System.out.println("\n========== 🌙 睡眠模式启动 ==========");

        // 关闭大部分灯光
        lightingSystem.turnOffLight("客厅");
        lightingSystem.turnOffLight("厨房");
        lightingSystem.turnOffLight("卫生间");
        lightingSystem.turnOnLight("卧室");
        lightingSystem.setBrightness(20);

        // 空调设置为睡眠温度
        acSystem.setTemperature(26);
        acSystem.setMode("睡眠");

        // 关闭音响和电视
        audioSystem.turnOff();
        tvSystem.turnOff();

        // 关闭窗帘
        curtainSystem.close();

        // 启动安防
        securitySystem.arm();
        securitySystem.lockDoors();

        System.out.println("晚安，祝您好梦！");
        System.out.println("=====================================\n");
    }

    /**
     * 场景4：观影模式
     */
    public void movieMode() {
        System.out.println("\n========== 🎬 观影模式启动 ==========");

        // 调暗灯光
        lightingSystem.dimLights();

        // 关闭窗帘
        curtainSystem.close();

        // 空调舒适模式
        acSystem.setTemperature(24);

        // 打开电视
        tvSystem.turnOn();
        tvSystem.setVolume(40);
        tvSystem.launchApp("Netflix");

        // 打开音响（家庭影院模式）
        audioSystem.turnOn();
        audioSystem.setSource("HDMI");
        audioSystem.setVolume(60);

        System.out.println("影院环境已就绪，尽享观影时光！");
        System.out.println("=====================================\n");
    }

    /**
     * 场景5：派对模式
     */
    public void partyMode() {
        System.out.println("\n========== 🎉 派对模式启动 ==========");

        // 开启所有灯光
        lightingSystem.turnOnAllLights();
        lightingSystem.setBrightness(100);

        // 打开窗帘
        curtainSystem.open();

        // 空调舒适模式
        acSystem.setTemperature(22);

        // 打开音响
        audioSystem.turnOn();
        audioSystem.setSource("蓝牙");
        audioSystem.setVolume(80);
        audioSystem.playMusic("派对音乐列表");

        // 解除安防
        securitySystem.disarm();
        securitySystem.unlockDoors();

        System.out.println("派对时间！Let's party! 🎊");
        System.out.println("=====================================\n");
    }

    /**
     * 场景6：阅读模式
     */
    public void readingMode() {
        System.out.println("\n========== 📖 阅读模式启动 ==========");

        // 适中灯光
        lightingSystem.turnOnLight("客厅");
        lightingSystem.setBrightness(70);

        // 窗帘半开
        curtainSystem.setPosition(30);

        // 空调舒适温度
        acSystem.setTemperature(23);

        // 轻音乐
        audioSystem.turnOn();
        audioSystem.setVolume(20);
        audioSystem.playMusic("轻音乐");

        // 关闭电视
        tvSystem.turnOff();

        System.out.println("阅读环境已准备好，享受阅读时光！");
        System.out.println("=====================================\n");
    }

    /**
     * 场景7：早晨唤醒模式
     */
    public void wakeUpMode() {
        System.out.println("\n========== ☀️ 早晨唤醒模式启动 ==========");

        // 逐渐打开窗帘
        System.out.println("  🪟 窗帘缓慢打开...");
        for (int i = 0; i <= 100; i += 25) {
            curtainSystem.setPosition(i);
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // 逐渐增加灯光亮度
        System.out.println("  💡 灯光渐亮...");
        lightingSystem.turnOnLight("卧室");
        lightingSystem.setBrightness(30);

        // 播放轻柔音乐
        audioSystem.turnOn();
        audioSystem.setVolume(15);
        audioSystem.playMusic("早晨轻音乐");

        // 舒适温度
        acSystem.setTemperature(24);

        // 解除安防
        securitySystem.disarm();

        System.out.println("早安！新的一天开始了！");
        System.out.println("========================================\n");
    }

    /**
     * 场景8：紧急模式
     */
    public void emergencyMode() {
        System.out.println("\n========== 🚨 紧急模式启动 ==========");

        // 所有灯光全开
        lightingSystem.turnOnAllLights();
        lightingSystem.setBrightness(100);

        // 打开窗帘
        curtainSystem.open();

        // 解锁所有门
        securitySystem.unlockDoors();
        securitySystem.disarm();

        // 停止所有娱乐设备
        audioSystem.turnOff();
        tvSystem.turnOff();

        System.out.println("⚠️ 紧急模式已激活！所有通道已打开！");
        System.out.println("=====================================\n");
    }

    // 提供对各子系统的直接访问（可选）
    public LightingSystem getLightingSystem() { return lightingSystem; }
    public AirConditioningSystem getAcSystem() { return acSystem; }
    public AudioSystem getAudioSystem() { return audioSystem; }
    public CurtainSystem getCurtainSystem() { return curtainSystem; }
    public TVSystem getTvSystem() { return tvSystem; }
    public SecuritySystem getSecuritySystem() { return securitySystem; }
}

/**
 * 使用示例
 */
public class FacadeDemo {
    public static void main(String[] args) {
        SmartHomeFacade smartHome = new SmartHomeFacade();

        System.out.println("========== 智能家居控制系统演示 ==========\n");

        // 场景1：早上起床
        System.out.println("【场景1】早上7点，该起床了");
        smartHome.wakeUpMode();
        sleep(1000);

        // 场景2：出门上班
        System.out.println("【场景2】8点半，出门上班");
        smartHome.leaveHome();
        sleep(1000);

        // 场景3：下班回家
        System.out.println("【场景3】晚上7点，下班回家");
        smartHome.arriveHome();
        sleep(1000);

        // 场景4：晚饭后看电影
        System.out.println("【场景4】晚上8点，看电影放松");
        smartHome.movieMode();
        sleep(1000);

        // 场景5：电影结束，阅读一会
        System.out.println("【场景5】晚上10点，读会书");
        smartHome.readingMode();
        sleep(1000);

        // 场景6：准备睡觉
        System.out.println("【场景6】晚上11点，准备睡觉");
        smartHome.sleepMode();
        sleep(1000);

        // 场景7：周末派对
        System.out.println("\n【特殊场景】周末开派对");
        smartHome.partyMode();
        sleep(1000);

        // 场景8：展示外观模式的优势
        System.out.println("\n========== 外观模式的优势 ==========");
        System.out.println("❌ 不使用外观模式（客户端需要操作6个子系统）:");
        System.out.println("  LightingSystem lights = new LightingSystem();");
        System.out.println("  lights.turnOffAllLights();");
        System.out.println("  AirConditioningSystem ac = new AirConditioningSystem();");
        System.out.println("  ac.turnOff();");
        System.out.println("  AudioSystem audio = new AudioSystem();");
        System.out.println("  audio.turnOff();");
        System.out.println("  ... 还需要操作另外3个系统 ...");
        System.out.println("\n✅ 使用外观模式（一行代码搞定）:");
        System.out.println("  smartHome.leaveHome();");
        System.out.println("\n简化了客户端代码，降低了使用复杂度！");

        // 场景9：仍可直接访问子系统
        System.out.println("\n========== 外观模式的灵活性 ==========");
        System.out.println("外观模式不限制直接访问子系统，提供了灵活性：");
        smartHome.getLightingSystem().turnOnLight("厨房");
        smartHome.getAudioSystem().setVolume(35);
        System.out.println("可以在场景模式基础上进行微调！\n");

        // 场景10：紧急情况
        System.out.println("【紧急情况】火灾警报！");
        smartHome.emergencyMode();
    }

    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 11. 享元模式（Flyweight Pattern）

**使用场景**：

* 大量相似对象
* 对象状态可以外部化
* 内存消耗大
* 游戏中的子弹、粒子

**好处：**

- 大幅减少对象数量
- 降低内存占用
- 提高系统性能

**解决的问题：**

- 需要创建大量相似对象
- 系统内存占用过高
- 对象创建开销大

**缺点：**

- 增加系统复杂度
- 需要分离内部状态和外部状态
- 外部状态需要客户端维护

**详细案例：文本编辑器字符渲染系统**

```java
/**
 * 字符样式（享元对象）
 */
public class CharacterStyle {
    // 内部状态（共享）
    private final String fontFamily;
    private final int fontSize;
    private final String color;
    private final boolean bold;
    private final boolean italic;
    private final boolean underline;

    public CharacterStyle(String fontFamily, int fontSize, String color,
                          boolean bold, boolean italic, boolean underline) {
        this.fontFamily = fontFamily;
        this.fontSize = fontSize;
        this.color = color;
        this.bold = bold;
        this.italic = italic;
        this.underline = underline;

        // 模拟对象创建的开销
        System.out.println("    创建新样式对象: " + this.getStyleKey());
    }

    /**
     * 渲染字符（使用外部状态：字符和位置）
     */
    public void render(char character, int x, int y) {
        // 使用内部状态和外部状态进行渲染
        String style = String.format("字体:%s %dpx %s%s%s",
            fontFamily, fontSize, color,
            bold ? " 粗体" : "",
            italic ? " 斜体" : "");

        // 模拟渲染过程（实际应该调用图形库）
        // System.out.printf("渲染 '%c' 在(%d,%d) - %s\n", character, x, y, style);
    }

    /**
     * 获取样式的唯一标识
     */
    public String getStyleKey() {
        return String.format("%s-%d-%s-%b-%b-%b",
            fontFamily, fontSize, color, bold, italic, underline);
    }

    // Getters
    public String getFontFamily() { return fontFamily; }
    public int getFontSize() { return fontSize; }
    public String getColor() { return color; }
    public boolean isBold() { return bold; }
    public boolean isItalic() { return italic; }
    public boolean isUnderline() { return underline; }

    @Override
    public String toString() {
        return String.format("%s %dpx %s%s%s%s",
            fontFamily, fontSize, color,
            bold ? " 粗体" : "",
            italic ? " 斜体" : "",
            underline ? " 下划线" : "");
    }
}

/**
 * 享元工厂
 */
public class CharacterStyleFactory {
    private static final Map<String, CharacterStyle> stylePool = new HashMap<>();
    private static int createCount = 0;
    private static int requestCount = 0;

    /**
     * 获取字符样式（享元模式核心）
     */
    public static CharacterStyle getStyle(String fontFamily, int fontSize, String color,
                                          boolean bold, boolean italic, boolean underline) {
        requestCount++;

        String key = String.format("%s-%d-%s-%b-%b-%b",
            fontFamily, fontSize, color, bold, italic, underline);

        CharacterStyle style = stylePool.get(key);

        if (style == null) {
            style = new CharacterStyle(fontFamily, fontSize, color, bold, italic, underline);
            stylePool.put(key, style);
            createCount++;
        }

        return style;
    }

    /**
     * 获取常用样式
     */
    public static CharacterStyle getDefaultStyle() {
        return getStyle("Arial", 12, "black", false, false, false);
    }

    public static CharacterStyle getHeadingStyle() {
        return getStyle("Arial", 24, "black", true, false, false);
    }

    public static CharacterStyle getBoldStyle() {
        return getStyle("Arial", 12, "black", true, false, false);
    }

    public static CharacterStyle getItalicStyle() {
        return getStyle("Arial", 12, "black", false, true, false);
    }

    public static CharacterStyle getLinkStyle() {
        return getStyle("Arial", 12, "blue", false, false, true);
    }

    /**
     * 获取统计信息
     */
    public static void printStatistics() {
        System.out.println("\n========== 享元工厂统计 ==========");
        System.out.println("样式请求总数: " + requestCount);
        System.out.println("实际创建对象数: " + createCount);
        System.out.println("对象池大小: " + stylePool.size());
        System.out.println("重用率: " + String.format("%.2f%%", 
            (requestCount - createCount) * 100.0 / requestCount));
        System.out.println("内存节省: " + String.format("%.2f%%",
            (requestCount - createCount) * 100.0 / requestCount));
        System.out.println("===============================\n");
    }

    public static void reset() {
        stylePool.clear();
        createCount = 0;
        requestCount = 0;
    }

    public static int getPoolSize() {
        return stylePool.size();
    }
}

/**
 * 文档字符（包含外部状态）
 */
public class DocumentCharacter {
    private char character;      // 外部状态：字符内容
    private int x;              // 外部状态：x坐标
    private int y;              // 外部状态：y坐标
    private CharacterStyle style; // 内部状态（共享）

    public DocumentCharacter(char character, int x, int y, CharacterStyle style) {
        this.character = character;
        this.x = x;
        this.y = y;
        this.style = style;
    }

    public void render() {
        style.render(character, x, y);
    }

    public char getCharacter() { return character; }
    public CharacterStyle getStyle() { return style; }
}

/**
 * 文档类
 */
public class Document {
    private String title;
    private List<DocumentCharacter> characters;

    public Document(String title) {
        this.title = title;
        this.characters = new ArrayList<>();
    }

    public void addText(String text, int startX, int startY, CharacterStyle style) {
        int x = startX;
        int y = startY;

        for (char c : text.toCharArray()) {
            if (c == '\n') {
                x = startX;
                y += style.getFontSize() + 5; // 行间距
            } else {
                characters.add(new DocumentCharacter(c, x, y, style));
                x += style.getFontSize() / 2; // 字符间距（简化）
            }
        }
    }

    public void render() {
        System.out.println("\n========== 渲染文档: " + title + " ==========");
        characters.forEach(DocumentCharacter::render);
        System.out.println("==========================================\n");
    }

    public int getCharacterCount() {
        return characters.size();
    }

    public String getContent() {
        StringBuilder sb = new StringBuilder();
        for (DocumentCharacter dc : characters) {
            sb.append(dc.getCharacter());
        }
        return sb.toString();
    }

    public void printInfo() {
        System.out.println("文档: " + title);
        System.out.println("字符数: " + characters.size());
        System.out.println("使用的样式数: " + getUniqueStyleCount());
    }

    private int getUniqueStyleCount() {
        Set<CharacterStyle> uniqueStyles = new HashSet<>();
        for (DocumentCharacter dc : characters) {
            uniqueStyles.add(dc.getStyle());
        }
        return uniqueStyles.size();
    }
}

/**
 * 内存使用对比工具
 */
public class MemoryComparison {

    /**
     * 不使用享元模式的字符类
     */
    static class CharacterWithoutFlyweight {
        private char character;
        private int x, y;
        // 每个字符都有自己的样式属性（不共享）
        private String fontFamily;
        private int fontSize;
        private String color;
        private boolean bold;
        private boolean italic;
        private boolean underline;

        public CharacterWithoutFlyweight(char character, int x, int y,
                                        String fontFamily, int fontSize, String color,
                                        boolean bold, boolean italic, boolean underline) {
            this.character = character;
            this.x = x;
            this.y = y;
            this.fontFamily = fontFamily;
            this.fontSize = fontSize;
            this.color = color;
            this.bold = bold;
            this.italic = italic;
            this.underline = underline;
        }
    }

    /**
     * 估算对象大小（简化版）
     */
    public static long estimateObjectSize(Object obj) {
        if (obj instanceof CharacterWithoutFlyweight) {
            // char(2) + int(4)*2 + String引用*2(16) + int(4) + boolean*3(3) = ~35字节
            // 加上对象头(12字节) ≈ 50字节
            return 50;
        } else if (obj instanceof DocumentCharacter) {
            // char(2) + int(4)*2 + CharacterStyle引用(8) = 22字节
            // 加上对象头 ≈ 35字节
            return 35;
        } else if (obj instanceof CharacterStyle) {
            // String引用*2 + int + boolean*3 ≈ 30字节
            return 30;
        }
        return 0;
    }

    /**
     * 对比内存使用
     */
    public static void compare(int characterCount, int uniqueStyleCount) {
        System.out.println("\n========== 内存使用对比 ==========");
        System.out.println("场景: " + characterCount + " 个字符，" + 
                         uniqueStyleCount + " 种不同样式");

        // 不使用享元模式
        long withoutFlyweight = characterCount * 50;

        // 使用享元模式
        long withFlyweight = characterCount * 35 + uniqueStyleCount * 30;

        System.out.println("\n不使用享元模式:");
        System.out.println("  总内存: " + withoutFlyweight + " 字节 ≈ " + 
                         (withoutFlyweight / 1024) + " KB");

        System.out.println("\n使用享元模式:");
        System.out.println("  DocumentCharacter对象: " + (characterCount * 35) + " 字节");
        System.out.println("  CharacterStyle对象: " + (uniqueStyleCount * 30) + " 字节");
        System.out.println("  总内存: " + withFlyweight + " 字节 ≈ " + 
                         (withFlyweight / 1024) + " KB");

        long saved = withoutFlyweight - withFlyweight;
        double percentage = saved * 100.0 / withoutFlyweight;

        System.out.println("\n节省内存: " + saved + " 字节 ≈ " + 
                         (saved / 1024) + " KB");
        System.out.println("节省比例: " + String.format("%.2f%%", percentage));
        System.out.println("================================\n");
    }
}

/**
 * 使用示例
 */
public class FlyweightDemo {
    public static void main(String[] args) {
        System.out.println("========== 文本编辑器 - 享元模式演示 ==========\n");

        // 场景1：创建一个文档
        System.out.println("【场景1】创建包含多种样式的文档\n");

        Document doc = new Document("技术文档.txt");

        // 标题（大号粗体）
        CharacterStyle headingStyle = CharacterStyleFactory.getHeadingStyle();
        doc.addText("设计模式详解\n", 0, 0, headingStyle);

        // 正文（默认样式）
        CharacterStyle normalStyle = CharacterStyleFactory.getDefaultStyle();
        doc.addText("设计模式是软件工程中常用的解决方案。", 0, 40, normalStyle);
        doc.addText("本文介绍享元模式的应用。\n", 0, 60, normalStyle);

        // 粗体文字
        CharacterStyle boldStyle = CharacterStyleFactory.getBoldStyle();
        doc.addText("享元模式", 0, 100, boldStyle);

        // 普通文字
        doc.addText("可以大幅减少内存占用。\n", 100, 100, normalStyle);

        // 链接（蓝色下划线）
        CharacterStyle linkStyle = CharacterStyleFactory.getLinkStyle();
        doc.addText("https://example.com", 0, 140, linkStyle);

        // 斜体
        CharacterStyle italicStyle = CharacterStyleFactory.getItalicStyle();
        doc.addText("\n注：这是一个示例。", 0, 180, italicStyle);

        // 输出文档信息
        doc.printInfo();
        CharacterStyleFactory.printStatistics();

        // 场景2：大规模文档测试
        System.out.println("\n【场景2】大规模文档性能测试\n");
        CharacterStyleFactory.reset();

        Document largeDoc = new Document("大型文档.txt");

        // 创建包含10000个字符的文档
        String content = "这是一个很长的文档内容。".repeat(1000);

        System.out.println("添加10000+字符...");
        long startTime = System.currentTimeMillis();

        for (int i = 0; i < content.length(); i += 100) {
            String chunk = content.substring(i, Math.min(i + 100, content.length()));
            CharacterStyle style;

            // 随机选择样式（模拟真实文档）
            int styleType = i % 5;
            switch (styleType) {
                case 0: style = CharacterStyleFactory.getDefaultStyle(); break;
                case 1: style = CharacterStyleFactory.getBoldStyle(); break;
                case 2: style = CharacterStyleFactory.getItalicStyle(); break;
                case 3: style = CharacterStyleFactory.getLinkStyle(); break;
                default: style = CharacterStyleFactory.getHeadingStyle();
            }

            largeDoc.addText(chunk, 0, i * 20, style);
        }

        long endTime = System.currentTimeMillis();

        System.out.println("完成！耗时: " + (endTime - startTime) + " ms");
        largeDoc.printInfo();
        CharacterStyleFactory.printStatistics();

        // 场景3：内存使用对比
        System.out.println("\n【场景3】内存使用对比\n");

        int charCount = largeDoc.getCharacterCount();
        int styleCount = CharacterStyleFactory.getPoolSize();

        MemoryComparison.compare(charCount, styleCount);

        // 场景4：更极端的场景
        System.out.println("【场景4】极端场景 - 100万字符文档\n");
        MemoryComparison.compare(1000000, 20);

        // 场景5：享元模式的优势总结
        System.out.println("========== 享元模式的优势 ==========");
        System.out.println("1. 内存优化: 共享相同的样式对象，大幅减少内存占用");
        System.out.println("2. 性能提升: 减少对象创建次数，提高系统性能");
        System.out.println("3. 适用场景: 大量相似对象，内部状态可共享");
        System.out.println("4. 典型应用: 文本编辑器、游戏中的粒子系统、数据库连接池");

        System.out.println("\n========== 享元模式的注意事项 ==========");
        System.out.println("1. 需要正确区分内部状态和外部状态");
        System.out.println("2. 享元对象必须是不可变的（线程安全）");
        System.out.println("3. 外部状态由客户端维护和传递");
        System.out.println("4. 增加了系统复杂度，需要权衡收益");

        // 场景6：对比不使用享元模式的情况
        System.out.println("\n========== 场景6：性能对比 ==========");

        System.out.println("❌ 不使用享元模式:");
        System.out.println("  每个字符都创建完整的样式对象");
        System.out.println("  10000个字符 = 10000个样式对象");
        System.out.println("  内存占用: ~500 KB");

        System.out.println("\n✅ 使用享元模式:");
        System.out.println("  共享样式对象");
        System.out.println("  10000个字符 + 5个样式对象");
        System.out.println("  内存占用: ~350 KB");
        System.out.println("  节省: 30%");

        System.out.println("\n当文档更大时，节省更明显:");
        System.out.println("  100万字符：不使用享元 ~50 MB，使用享元 ~35 MB");
        System.out.println("  节省: ~15 MB (30%)");
    }
}
```



我将继续讲解最后一个结构型模式和行为型模式。

### 12. 代理模式（Proxy Pattern）

**使用场景**：

* 远程代理
* 虚拟代理
* 安全代理
* 智能引用

**好处：**

- 控制对对象的访问
- 增强对象功能而不修改对象本身
- 延迟加载（虚拟代理）
- 访问控制（保护代理）
- 远程访问（远程代理）

**解决的问题：**

- 直接访问对象成本高或不安全
- 需要在访问对象时添加额外逻辑
- 对象创建开销大，需要延迟创建

**缺点：**

- 增加系统复杂度
- 可能影响性能（额外的间接层）
- 实现较为复杂

**详细案例：图片加载代理系统**

```java
/**
 * 图片接口
 */
public interface Image {
    void display();
    String getFileName();
    long getFileSize();
    int getWidth();
    int getHeight();
}

/**
 * 真实图片类
 */
public class RealImage implements Image {
    private String fileName;
    private byte[] imageData;
    private int width;
    private int height;
    private long fileSize;
    private LocalDateTime loadTime;

    public RealImage(String fileName) {
        this.fileName = fileName;
        loadImageFromDisk();
    }

    /**
     * 从磁盘加载图片（耗时操作）
     */
    private void loadImageFromDisk() {
        System.out.println("  📥 正在从磁盘加载图片: " + fileName);

        // 模拟耗时的IO操作
        try {
            Thread.sleep(1000); // 模拟加载延迟

            // 模拟图片数据
            this.imageData = new byte[1024 * 1024 * 5]; // 5MB
            this.width = 1920;
            this.height = 1080;
            this.fileSize = imageData.length;
            this.loadTime = LocalDateTime.now();

            System.out.println("  ✅ 图片加载完成: " + fileName + 
                             " (大小: " + (fileSize / 1024 / 1024) + " MB)");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void display() {
        System.out.println("  🖼️  显示图片: " + fileName + 
                         " (" + width + "x" + height + ")");
    }

    @Override
    public String getFileName() {
        return fileName;
    }

    @Override
    public long getFileSize() {
        return fileSize;
    }

    @Override
    public int getWidth() {
        return width;
    }

    @Override
    public int getHeight() {
        return height;
    }
}

/**
 * 虚拟代理：延迟加载图片
 */
public class VirtualImageProxy implements Image {
    private String fileName;
    private RealImage realImage;
    private LocalDateTime createTime;

    public VirtualImageProxy(String fileName) {
        this.fileName = fileName;
        this.createTime = LocalDateTime.now();
        System.out.println("  📝 创建图片代理: " + fileName + " (未加载)");
    }

    @Override
    public void display() {
        // 延迟加载：只有在真正需要显示时才加载
        if (realImage == null) {
            System.out.println("  ⏳ 首次访问，触发加载...");
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }

    @Override
    public String getFileName() {
        return fileName;
    }

    @Override
    public long getFileSize() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        return realImage.getFileSize();
    }

    @Override
    public int getWidth() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        return realImage.getWidth();
    }

    @Override
    public int getHeight() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        return realImage.getHeight();
    }

    public boolean isLoaded() {
        return realImage != null;
    }
}

/**
 * 保护代理：访问控制
 */
public class ProtectedImageProxy implements Image {
    private RealImage realImage;
    private String fileName;
    private UserRole currentUserRole;

    public enum UserRole {
        ADMIN, USER, GUEST
    }

    public ProtectedImageProxy(String fileName, UserRole userRole) {
        this.fileName = fileName;
        this.currentUserRole = userRole;
        System.out.println("  🔒 创建保护代理 - 用户角色: " + userRole);
    }

    @Override
    public void display() {
        if (!hasPermission()) {
            System.out.println("  ❌ 访问被拒绝: 权限不足！");
            System.out.println("     需要权限: ADMIN 或 USER");
            System.out.println("     当前角色: " + currentUserRole);
            return;
        }

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }

    @Override
    public String getFileName() {
        return fileName;
    }

    @Override
    public long getFileSize() {
        if (!hasPermission()) {
            throw new SecurityException("权限不足");
        }
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        return realImage.getFileSize();
    }

    @Override
    public int getWidth() {
        // 基本信息可以查看
        if (realImage == null) {
            return 0; // 返回默认值而不加载
        }
        return realImage.getWidth();
    }

    @Override
    public int getHeight() {
        if (realImage == null) {
            return 0;
        }
        return realImage.getHeight();
    }

    private boolean hasPermission() {
        // GUEST没有权限，ADMIN和USER有权限
        return currentUserRole == UserRole.ADMIN || 
               currentUserRole == UserRole.USER;
    }
}

/**
 * 缓存代理：缓存结果
 */
public class CachingImageProxy implements Image {
    private RealImage realImage;
    private String fileName;
    private Map<String, Object> cache;

    public CachingImageProxy(String fileName) {
        this.fileName = fileName;
        this.cache = new HashMap<>();
        System.out.println("  💾 创建缓存代理: " + fileName);
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }

        // 检查缓存
        if (cache.containsKey("display")) {
            System.out.println("  ⚡ 从缓存读取显示信息");
        } else {
            realImage.display();
            cache.put("display", true);
        }
    }

    @Override
    public String getFileName() {
        return fileName;
    }

    @Override
    public long getFileSize() {
        if (cache.containsKey("fileSize")) {
            System.out.println("  ⚡ 从缓存读取文件大小");
            return (long) cache.get("fileSize");
        }

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        long size = realImage.getFileSize();
        cache.put("fileSize", size);
        return size;
    }

    @Override
    public int getWidth() {
        if (cache.containsKey("width")) {
            return (int) cache.get("width");
        }

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        int width = realImage.getWidth();
        cache.put("width", width);
        return width;
    }

    @Override
    public int getHeight() {
        if (cache.containsKey("height")) {
            return (int) cache.get("height");
        }

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        int height = realImage.getHeight();
        cache.put("height", height);
        return height;
    }
}

/**
 * 日志代理：记录访问日志
 */
public class LoggingImageProxy implements Image {
    private RealImage realImage;
    private String fileName;
    private List<String> accessLog;

    public LoggingImageProxy(String fileName) {
        this.fileName = fileName;
        this.accessLog = new ArrayList<>();
        System.out.println("  📋 创建日志代理: " + fileName);
    }

    @Override
    public void display() {
        logAccess("display()");

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }

    @Override
    public String getFileName() {
        logAccess("getFileName()");
        return fileName;
    }

    @Override
    public long getFileSize() {
        logAccess("getFileSize()");

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        return realImage.getFileSize();
    }

    @Override
    public int getWidth() {
        logAccess("getWidth()");

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        return realImage.getWidth();
    }

    @Override
    public int getHeight() {
        logAccess("getHeight()");

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        return realImage.getHeight();
    }

    private void logAccess(String method) {
        String logEntry = String.format("[%s] %s - %s",
            LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss")),
            fileName, method);
        accessLog.add(logEntry);
        System.out.println("  📋 日志: " + logEntry);
    }

    public void printAccessLog() {
        System.out.println("\n========== 访问日志 ==========");
        accessLog.forEach(System.out::println);
        System.out.println("============================\n");
    }
}

/**
 * 智能代理：组合多种代理功能
 */
public class SmartImageProxy implements Image {
    private RealImage realImage;
    private String fileName;
    private Map<String, Object> cache;
    private List<String> accessLog;
    private ProtectedImageProxy.UserRole userRole;

    public SmartImageProxy(String fileName, ProtectedImageProxy.UserRole userRole) {
        this.fileName = fileName;
        this.userRole = userRole;
        this.cache = new HashMap<>();
        this.accessLog = new ArrayList<>();
        System.out.println("  🧠 创建智能代理: " + fileName);
    }

    @Override
    public void display() {
        logAccess("display()");

        if (!hasPermission()) {
            System.out.println("  ❌ 访问被拒绝: 权限不足！");
            return;
        }

        // 延迟加载
        if (realImage == null) {
            System.out.println("  ⏳ 延迟加载图片...");
            realImage = new RealImage(fileName);
        }

        // 使用缓存
        if (cache.containsKey("display")) {
            System.out.println("  ⚡ 使用缓存的显示信息");
        } else {
            realImage.display();
            cache.put("display", true);
        }
    }

    @Override
    public String getFileName() {
        return fileName;
    }

    @Override
    public long getFileSize() {
        logAccess("getFileSize()");

        if (!hasPermission()) {
            throw new SecurityException("权限不足");
        }

        // 缓存检查
        if (cache.containsKey("fileSize")) {
            System.out.println("  ⚡ 从缓存读取");
            return (long) cache.get("fileSize");
        }

        if (realImage == null) {
            realImage = new RealImage(fileName);
        }

        long size = realImage.getFileSize();
        cache.put("fileSize", size);
        return size;
    }

    @Override
    public int getWidth() {
        if (realImage == null) {
            return 0;
        }
        return realImage.getWidth();
    }

    @Override
    public int getHeight() {
        if (realImage == null) {
            return 0;
        }
        return realImage.getHeight();
    }

    private boolean hasPermission() {
        return userRole == ProtectedImageProxy.UserRole.ADMIN || 
               userRole == ProtectedImageProxy.UserRole.USER;
    }

    private void logAccess(String method) {
        String logEntry = String.format("[%s] %s - %s",
            LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss")),
            fileName, method);
        accessLog.add(logEntry);
    }

    public void printStatistics() {
        System.out.println("\n========== 代理统计 ==========");
        System.out.println("图片: " + fileName);
        System.out.println("是否已加载: " + (realImage != null));
        System.out.println("缓存项数: " + cache.size());
        System.out.println("访问次数: " + accessLog.size());
        System.out.println("============================\n");
    }
}

/**
 * 使用示例
 */
public class ProxyDemo {
    public static void main(String[] args) {
        System.out.println("========== 代理模式演示 ==========\n");

        // 场景1：虚拟代理 - 延迟加载
        System.out.println("【场景1】虚拟代理 - 延迟加载");
        System.out.println("不使用代理的情况：");
        long start = System.currentTimeMillis();
        RealImage img1 = new RealImage("photo1.jpg");
        RealImage img2 = new RealImage("photo2.jpg");
        RealImage img3 = new RealImage("photo3.jpg");
        long end = System.currentTimeMillis();
        System.out.println("加载3张图片耗时: " + (end - start) + "ms\n");

        System.out.println("使用虚拟代理：");
        start = System.currentTimeMillis();
        Image proxy1 = new VirtualImageProxy("photo4.jpg");
        Image proxy2 = new VirtualImageProxy("photo5.jpg");
        Image proxy3 = new VirtualImageProxy("photo6.jpg");
        end = System.currentTimeMillis();
        System.out.println("创建3个代理耗时: " + (end - start) + "ms");
        System.out.println("此时图片还未加载！");

        System.out.println("\n当用户真正需要查看图片时才加载：");
        proxy1.display(); // 此时才真正加载
        System.out.println();

        // 场景2：保护代理 - 访问控制
        System.out.println("\n【场景2】保护代理 - 访问控制");

        System.out.println("\nADMIN用户访问:");
        Image adminImage = new ProtectedImageProxy("sensitive.jpg", 
            ProtectedImageProxy.UserRole.ADMIN);
        adminImage.display();

        System.out.println("\nUSER用户访问:");
        Image userImage = new ProtectedImageProxy("sensitive.jpg", 
            ProtectedImageProxy.UserRole.USER);
        userImage.display();

        System.out.println("\nGUEST用户访问:");
        Image guestImage = new ProtectedImageProxy("sensitive.jpg", 
            ProtectedImageProxy.UserRole.GUEST);
        guestImage.display();
        System.out.println();

        // 场景3：缓存代理
        System.out.println("\n【场景3】缓存代理 - 提高性能");
        Image cachingProxy = new CachingImageProxy("large_image.jpg");

        System.out.println("\n第一次获取文件大小:");
        cachingProxy.getFileSize();

        System.out.println("\n第二次获取文件大小（从缓存）:");
        cachingProxy.getFileSize();
        System.out.println();

        // 场景4：日志代理
        System.out.println("\n【场景4】日志代理 - 记录访问");
        LoggingImageProxy loggingProxy = new LoggingImageProxy("document.jpg");
        loggingProxy.display();
        loggingProxy.getFileName();
        loggingProxy.getFileSize();
        loggingProxy.printAccessLog();

        // 场景5：智能代理 - 组合功能
        System.out.println("【场景5】智能代理 - 组合多种功能");
        SmartImageProxy smartProxy = new SmartImageProxy("smart_image.jpg", 
            ProtectedImageProxy.UserRole.ADMIN);

        System.out.println("\n第一次访问:");
        smartProxy.display();

        System.out.println("\n第二次访问（使用缓存）:");
        smartProxy.display();

        smartProxy.printStatistics();

        // 场景6：性能对比
        System.out.println("【场景6】性能对比");
        System.out.println("\n模拟图片浏览器加载100张图片的缩略图：");

        System.out.println("\n❌ 不使用代理：");
        System.out.println("  立即加载所有图片 → 100 * 1秒 = 100秒");
        System.out.println("  初始化时间长，用户体验差");

        System.out.println("\n✅ 使用虚拟代理：");
        System.out.println("  创建100个代理 → 几乎瞬间完成");
        System.out.println("  只加载可见区域的图片 → 10 * 1秒 = 10秒");
        System.out.println("  大幅提升用户体验！");

        // 场景7：代理模式的应用场景总结
        System.out.println("\n========== 代理模式的应用场景 ==========");
        System.out.println("1. 虚拟代理: 延迟加载大对象（图片、视频、文档）");
        System.out.println("2. 保护代理: 控制访问权限（权限管理）");
        System.out.println("3. 远程代理: 访问远程对象（RPC、RMI）");
        System.out.println("4. 缓存代理: 缓存结果提高性能");
        System.out.println("5. 日志代理: 记录操作日志");
        System.out.println("6. 智能引用: 额外功能（引用计数、线程安全）");

        System.out.println("\n========== 代理模式 vs 装饰器模式 ==========");
        System.out.println("代理模式:");
        System.out.println("  - 目的：控制访问");
        System.out.println("  - 代理自己创建真实对象");
        System.out.println("  - 客户端不需要知道真实对象");

        System.out.println("\n装饰器模式:");
        System.out.println("  - 目的：增强功能");
        System.out.println("  - 装饰器接收已存在的对象");
        System.out.println("  - 客户端需要创建被装饰的对象");

        System.out.println("\n========== Spring AOP 就是代理模式的应用 ==========");
        System.out.println("Spring使用动态代理实现AOP:");
        System.out.println("  - JDK动态代理（基于接口）");
        System.out.println("  - CGLIB代理（基于继承）");
        System.out.println("  - 在方法调用前后添加切面逻辑");
    }
}
```

## 三、行为型模式

### 13. 责任链模式（Chain of Responsibility Pattern）

**使用场景**：

* 多个对象处理同一请求
* 审批流程
* 异常处理
* 事件处理

**好处：**

- 降低耦合度
- 增强灵活性
- 简化对象之间的连接
- 增加新的处理类很方便

**解决的问题：**

- 多个对象可以处理同一请求
- 请求的处理者需要在运行时动态确定
- 避免请求发送者和接收者耦合

**缺点：**

- 不保证请求一定被处理
- 性能受影响（需要遍历链）
- 调试困难

**详细案例：请假审批系统**

```java
/**
 * 请假申请
 */
public class LeaveRequest {
    private String employeeName;
    private String employeeId;
    private int leaveDays;
    private String reason;
    private String leaveType;
    private LocalDate startDate;
    private LocalDate endDate;
    private String requestId;

    public LeaveRequest(String employeeName, String employeeId, 
                       int leaveDays, String reason, String leaveType) {
        this.employeeName = employeeName;
        this.employeeId = employeeId;
        this.leaveDays = leaveDays;
        this.reason = reason;
        this.leaveType = leaveType;
        this.requestId = "REQ" + System.currentTimeMillis();
        this.startDate = LocalDate.now().plusDays(1);
        this.endDate = startDate.plusDays(leaveDays - 1);
    }

    public String getEmployeeName() { return employeeName; }
    public String getEmployeeId() { return employeeId; }
    public int getLeaveDays() { return leaveDays; }
    public String getReason() { return reason; }
    public String getLeaveType() { return leaveType; }
    public String getRequestId() { return requestId; }

    @Override
    public String toString() {
        return String.format("申请ID: %s | 员工: %s(%s) | 类型: %s | 天数: %d天 | 原因: %s",
            requestId, employeeName, employeeId, leaveType, leaveDays, reason);
    }
}

/**
 * 审批结果
 */
public class ApprovalResult {
    private boolean approved;
    private String approver;
    private String approverRole;
    private String comment;
    private LocalDateTime approvalTime;

    public ApprovalResult(boolean approved, String approver, 
                         String approverRole, String comment) {
        this.approved = approved;
        this.approver = approver;
        this.approverRole = approverRole;
        this.comment = comment;
        this.approvalTime = LocalDateTime.now();
    }

    public boolean isApproved() { return approved; }
    public String getApprover() { return approver; }
    public String getApproverRole() { return approverRole; }
    public String getComment() { return comment; }

    @Override
    public String toString() {
        String status = approved ? "✅ 批准" : "❌ 拒绝";
        return String.format("%s by %s(%s) - %s",
            status, approver, approverRole, comment);
    }
}

/**
 * 抽象审批者
 */
public abstract class Approver {
    protected String name;
    protected String role;
    protected Approver nextApprover;

    public Approver(String name, String role) {
        this.name = name;
        this.role = role;
    }

    /**
     * 设置下一个审批者
     */
    public void setNextApprover(Approver nextApprover) {
        this.nextApprover = nextApprover;
    }

    /**
     * 处理请假申请
     */
    public final ApprovalResult handleRequest(LeaveRequest request) {
        System.out.println("\n  📋 [" + role + " " + name + "] 正在审批...");

        // 判断是否有权限审批
        if (canApprove(request)) {
            ApprovalResult result = approve(request);
            System.out.println("  " + result);
            return result;
        } else {
            // 转发给下一级审批者
            if (nextApprover != null) {
                System.out.println("  ⏭️  超出权限，转交给 " + 
                                 nextApprover.role + " " + nextApprover.name);
                return nextApprover.handleRequest(request);
            } else {
                System.out.println("  ❌ 无人有权限审批此请求！");
                return new ApprovalResult(false, name, role, 
                    "超出所有人的审批权限");
            }
        }
    }

    /**
     * 判断是否有权限审批（由子类实现）
     */
    protected abstract boolean canApprove(LeaveRequest request);

    /**
     * 执行审批（由子类实现）
     */
    protected abstract ApprovalResult approve(LeaveRequest request);
}

/**
 * 组长（可审批1天以内）
 */
public class TeamLeader extends Approver {
    public TeamLeader(String name) {
        super(name, "组长");
    }

    @Override
    protected boolean canApprove(LeaveRequest request) {
        return request.getLeaveDays() <= 1;
    }

    @Override
    protected ApprovalResult approve(LeaveRequest request) {
        // 组长审批逻辑
        if (request.getReason().contains("私事") && request.getLeaveDays() > 0) {
            return new ApprovalResult(false, name, role, 
                "私事请假建议使用年假或调休");
        }

        return new ApprovalResult(true, name, role, 
            "1天以内的请假已批准");
    }
}

/**
 * 部门经理（可审批3天以内）
 */
public class DepartmentManager extends Approver {
    public DepartmentManager(String name) {
        super(name, "部门经理");
    }

    @Override
    protected boolean canApprove(LeaveRequest request) {
        return request.getLeaveDays() <= 3;
    }

    @Override
    protected ApprovalResult approve(LeaveRequest request) {
        // 部门经理审批逻辑
        if ("病假".equals(request.getLeaveType()) && 
            !request.getReason().contains("医院")) {
            return new ApprovalResult(false, name, role, 
                "病假需要提供医院证明");
        }

        return new ApprovalResult(true, name, role, 
            "3天以内的请假已批准，注意工作交接");
    }
}

/**
 * 总监（可审批7天以内）
 */
public class Director extends Approver {
    public Director(String name) {
        super(name, "总监");
    }

    @Override
    protected boolean canApprove(LeaveRequest request) {
        return request.getLeaveDays() <= 7;
    }

    @Override
    protected ApprovalResult approve(LeaveRequest request) {
        // 总监审批逻辑
        if (request.getLeaveDays() > 5) {
            return new ApprovalResult(true, name, role, 
                "长假已批准，请提前安排好工作，并指定代理人");
        }

        return new ApprovalResult(true, name, role, 
            "7天以内的请假已批准");
    }
}

/**
 * 副总经理（可审批15天以内）
 */
public class VicePresident extends Approver {
    public VicePresident(String name) {
        super(name, "副总经理");
    }

    @Override
    protected boolean canApprove(LeaveRequest request) {
        return request.getLeaveDays() <= 15;
    }

    @Override
    protected ApprovalResult approve(LeaveRequest request) {
        if (request.getLeaveDays() > 10) {
            return new ApprovalResult(true, name, role, 
                "超长假期已批准，需要人力资源部备案");
        }

        return new ApprovalResult(true, name, role, 
            "15天以内的请假已批准");
    }
}

/**
 * 总经理（可审批30天以内）
 */
public class President extends Approver {
    public President(String name) {
        super(name, "总经理");
    }

    @Override
    protected boolean canApprove(LeaveRequest request) {
        return request.getLeaveDays() <= 30;
    }

    @Override
    protected ApprovalResult approve(LeaveRequest request) {
        if (request.getLeaveDays() > 20) {
            return new ApprovalResult(true, name, role, 
                "特殊长假已批准，需要董事会备案，请做好详细的工作安排");
        }

        return new ApprovalResult(true, name, role, 
            "30天以内的请假已批准");
    }
}

/**
 * 请假审批系统
 */
public class LeaveApprovalSystem {
    private Approver approvalChain;

    public LeaveApprovalSystem() {
        buildApprovalChain();
    }

    /**
     * 构建审批链
     */
    private void buildApprovalChain() {
        // 创建各级审批者
        Approver teamLeader = new TeamLeader("张三");
        Approver manager = new DepartmentManager("李四");
        Approver director = new Director("王五");
        Approver vp = new VicePresident("赵六");
        Approver president = new President("孙七");

        // 构建责任链
        teamLeader.setNextApprover(manager);
        manager.setNextApprover(director);
        director.setNextApprover(vp);
        vp.setNextApprover(president);

        this.approvalChain = teamLeader;
    }

    /**
     * 提交请假申请
     */
    public ApprovalResult submitRequest(LeaveRequest request) {
        System.out.println("\n========================================");
        System.out.println("📄 新的请假申请");
        System.out.println(request);
        System.out.println("========================================");

        ApprovalResult result = approvalChain.handleRequest(request);

        System.out.println("\n========================================");
        System.out.println("审批流程结束");
        System.out.println("最终结果: " + result);
        System.out.println("========================================\n");

        return result;
    }
}

/**
 * 使用示例
 */
public class ChainOfResponsibilityDemo {
    public static void main(String[] args) {
        LeaveApprovalSystem system = new LeaveApprovalSystem();

        System.out.println("========== 请假审批系统 - 责任链模式 ==========\n");

        // 场景1：1天病假（组长审批）
        System.out.println("【场景1】1天病假");
        LeaveRequest request1 = new LeaveRequest(
            "员工A", "E001", 1, "感冒发烧", "病假");
        system.submitRequest(request1);

        // 场景2：3天年假（部门经理审批）
        System.out.println("【场景2】3天年假");
        LeaveRequest request2 = new LeaveRequest(
            "员工B", "E002", 3, "回家探亲", "年假");
        system.submitRequest(request2);

        // 场景3：5天婚假（总监审批）
        System.out.println("【场景3】5天婚假");
        LeaveRequest request3 = new LeaveRequest(
            "员工C", "E003", 5, "结婚", "婚假");
        system.submitRequest(request3);

        // 场景4：10天事假（副总经理审批）
        System.out.println("【场景4】10天事假");
        LeaveRequest request4 = new LeaveRequest(
            "员工D", "E004", 10, "家里有事需要处理", "事假");
        system.submitRequest(request4);

        // 场景5：25天产假（总经理审批）
        System.out.println("【场景5】25天产假");
        LeaveRequest request5 = new LeaveRequest(
            "员工E", "E005", 25, "生育", "产假");
        system.submitRequest(request5);

        // 场景6：超出权限的请假（无人审批）
        System.out.println("【场景6】35天超长假（超出所有人权限）");
        LeaveRequest request6 = new LeaveRequest(
            "员工F", "E006", 35, "出国旅游", "事假");
        system.submitRequest(request6);

        // 场景7：被拒绝的请假
        System.out.println("【场景7】病假但未提供医院证明");
        LeaveRequest request7 = new LeaveRequest(
            "员工G", "E007", 3, "身体不适", "病假");
        system.submitRequest(request7);

        // 责任链模式的优势
        System.out.println("\n========== 责任链模式的优势 ==========");
        System.out.println("1. 解耦: 请求者不需要知道谁会处理请求");
        System.out.println("2. 灵活: 可以动态添加或删除责任链节点");
        System.out.println("3. 简化: 每个处理者只关注自己的逻辑");
        System.out.println("4. 扩展性: 容易增加新的处理者");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. 审批流程（请假、报销、采购）");
        System.out.println("2. 异常处理（try-catch链）");
        System.out.println("3. 日志处理（不同级别的日志处理器）");
        System.out.println("4. Servlet过滤器链");
        System.out.println("5. Spring Security过滤器链");

        System.out.println("\n========== 如果不使用责任链模式 ==========");
        System.out.println("❌ 需要大量的if-else判断:");
        System.out.println("  if (days <= 1) { 组长审批 }");
        System.out.println("  else if (days <= 3) { 经理审批 }");
        System.out.println("  else if (days <= 7) { 总监审批 }");
        System.out.println("  ...");
        System.out.println("\n问题:");
        System.out.println("  - 代码耦合严重");
        System.out.println("  - 难以维护和扩展");
        System.out.println("  - 违反开闭原则");

        System.out.println("\n✅ 使用责任链模式:");
        System.out.println("  - 每个审批者独立");
        System.out.println("  - 请求沿着链传递");
        System.out.println("  - 易于添加新的审批级别");
    }
}
```



我将继续讲解剩余的行为型模式。

### 14. 命令模式（Command Pattern）

**使用场景**：

* 需要将请求封装为对象
* 支持撤销/重做
* 任务队列
* 事务处理

**好处：**

- 解耦调用者和接收者
- 支持撤销/重做操作
- 支持命令队列和日志
- 支持宏命令（组合命令）

**解决的问题：**

- 需要将请求封装成对象
- 需要支持撤销操作
- 需要记录命令历史

**缺点：**

- 可能产生大量命令类
- 增加系统复杂度

**详细案例：智能家居遥控器系统**

```java
/**
 * 命令接口
 */
public interface Command {
    void execute();
    void undo();
    String getDescription();
}

/**
 * 接收者：电灯
 */
public class Light {
    private String location;
    private boolean isOn;
    private int brightness;

    public Light(String location) {
        this.location = location;
        this.isOn = false;
        this.brightness = 0;
    }

    public void on() {
        isOn = true;
        brightness = 100;
        System.out.println("  💡 " + location + "的灯已打开（亮度100%）");
    }

    public void off() {
        isOn = false;
        brightness = 0;
        System.out.println("  💡 " + location + "的灯已关闭");
    }

    public void dim(int level) {
        if (level >= 0 && level <= 100) {
            isOn = level > 0;
            brightness = level;
            System.out.println("  💡 " + location + "的灯亮度调至 " + level + "%");
        }
    }

    public int getBrightness() {
        return brightness;
    }

    public boolean isOn() {
        return isOn;
    }
}

/**
 * 接收者：空调
 */
public class AirConditioner {
    private String location;
    private boolean isOn;
    private int temperature;

    public AirConditioner(String location) {
        this.location = location;
        this.isOn = false;
        this.temperature = 26;
    }

    public void on() {
        isOn = true;
        System.out.println("  ❄️ " + location + "的空调已开启");
    }

    public void off() {
        isOn = false;
        System.out.println("  ❄️ " + location + "的空调已关闭");
    }

    public void setTemperature(int temp) {
        if (!isOn) {
            on();
        }
        this.temperature = temp;
        System.out.println("  ❄️ " + location + "的空调温度设为 " + temp + "°C");
    }

    public int getTemperature() {
        return temperature;
    }

    public boolean isOn() {
        return isOn;
    }
}

/**
 * 接收者：音响
 */
public class Stereo {
    private String location;
    private boolean isOn;
    private int volume;
    private String source;

    public Stereo(String location) {
        this.location = location;
        this.isOn = false;
        this.volume = 0;
        this.source = "CD";
    }

    public void on() {
        isOn = true;
        System.out.println("  🔊 " + location + "的音响已开启");
    }

    public void off() {
        isOn = false;
        System.out.println("  🔊 " + location + "的音响已关闭");
    }

    public void setCD() {
        if (!isOn) on();
        source = "CD";
        System.out.println("  🔊 " + location + "的音响切换到CD模式");
    }

    public void setRadio() {
        if (!isOn) on();
        source = "Radio";
        System.out.println("  🔊 " + location + "的音响切换到收音机模式");
    }

    public void setVolume(int vol) {
        if (!isOn) on();
        volume = vol;
        System.out.println("  🔊 " + location + "的音响音量设为 " + vol);
    }

    public int getVolume() {
        return volume;
    }

    public boolean isOn() {
        return isOn;
    }
}

/**
 * 接收者：电视
 */
public class TV {
    private String location;
    private boolean isOn;
    private int channel;

    public TV(String location) {
        this.location = location;
        this.isOn = false;
        this.channel = 1;
    }

    public void on() {
        isOn = true;
        System.out.println("  📺 " + location + "的电视已开启");
    }

    public void off() {
        isOn = false;
        System.out.println("  📺 " + location + "的电视已关闭");
    }

    public void setChannel(int channel) {
        if (!isOn) on();
        this.channel = channel;
        System.out.println("  📺 " + location + "的电视切换到频道 " + channel);
    }

    public int getChannel() {
        return channel;
    }
}

// ========== 具体命令类 ==========

/**
 * 开灯命令
 */
public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.on();
    }

    @Override
    public void undo() {
        light.off();
    }

    @Override
    public String getDescription() {
        return "开灯";
    }
}

/**
 * 关灯命令
 */
public class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.off();
    }

    @Override
    public void undo() {
        light.on();
    }

    @Override
    public String getDescription() {
        return "关灯";
    }
}

/**
 * 调光命令
 */
public class LightDimCommand implements Command {
    private Light light;
    private int level;
    private int previousLevel;

    public LightDimCommand(Light light, int level) {
        this.light = light;
        this.level = level;
    }

    @Override
    public void execute() {
        previousLevel = light.getBrightness();
        light.dim(level);
    }

    @Override
    public void undo() {
        light.dim(previousLevel);
    }

    @Override
    public String getDescription() {
        return "调光至" + level + "%";
    }
}

/**
 * 空调开启命令
 */
public class ACOnCommand implements Command {
    private AirConditioner ac;

    public ACOnCommand(AirConditioner ac) {
        this.ac = ac;
    }

    @Override
    public void execute() {
        ac.on();
    }

    @Override
    public void undo() {
        ac.off();
    }

    @Override
    public String getDescription() {
        return "开启空调";
    }
}

/**
 * 空调关闭命令
 */
public class ACOffCommand implements Command {
    private AirConditioner ac;

    public ACOffCommand(AirConditioner ac) {
        this.ac = ac;
    }

    @Override
    public void execute() {
        ac.off();
    }

    @Override
    public void undo() {
        ac.on();
    }

    @Override
    public String getDescription() {
        return "关闭空调";
    }
}

/**
 * 设置空调温度命令
 */
public class ACSetTemperatureCommand implements Command {
    private AirConditioner ac;
    private int temperature;
    private int previousTemperature;

    public ACSetTemperatureCommand(AirConditioner ac, int temperature) {
        this.ac = ac;
        this.temperature = temperature;
    }

    @Override
    public void execute() {
        previousTemperature = ac.getTemperature();
        ac.setTemperature(temperature);
    }

    @Override
    public void undo() {
        ac.setTemperature(previousTemperature);
    }

    @Override
    public String getDescription() {
        return "设置空调温度为" + temperature + "°C";
    }
}

/**
 * 音响开启命令
 */
public class StereoOnCommand implements Command {
    private Stereo stereo;

    public StereoOnCommand(Stereo stereo) {
        this.stereo = stereo;
    }

    @Override
    public void execute() {
        stereo.on();
        stereo.setCD();
        stereo.setVolume(11);
    }

    @Override
    public void undo() {
        stereo.off();
    }

    @Override
    public String getDescription() {
        return "打开音响";
    }
}

/**
 * 音响关闭命令
 */
public class StereoOffCommand implements Command {
    private Stereo stereo;

    public StereoOffCommand(Stereo stereo) {
        this.stereo = stereo;
    }

    @Override
    public void execute() {
        stereo.off();
    }

    @Override
    public void undo() {
        stereo.on();
    }

    @Override
    public String getDescription() {
        return "关闭音响";
    }
}

/**
 * 电视开启命令
 */
public class TVOnCommand implements Command {
    private TV tv;

    public TVOnCommand(TV tv) {
        this.tv = tv;
    }

    @Override
    public void execute() {
        tv.on();
    }

    @Override
    public void undo() {
        tv.off();
    }

    @Override
    public String getDescription() {
        return "打开电视";
    }
}

/**
 * 空命令（什么都不做）
 */
public class NoCommand implements Command {
    @Override
    public void execute() {
        System.out.println("  ⚠️ 未设置命令");
    }

    @Override
    public void undo() {
        System.out.println("  ⚠️ 无可撤销的操作");
    }

    @Override
    public String getDescription() {
        return "空命令";
    }
}

/**
 * 宏命令（组合命令）
 */
public class MacroCommand implements Command {
    private List<Command> commands;
    private String description;

    public MacroCommand(List<Command> commands, String description) {
        this.commands = commands;
        this.description = description;
    }

    @Override
    public void execute() {
        System.out.println("  🎬 执行宏命令: " + description);
        for (Command command : commands) {
            command.execute();
        }
    }

    @Override
    public void undo() {
        System.out.println("  ⏪ 撤销宏命令: " + description);
        // 反向撤销
        for (int i = commands.size() - 1; i >= 0; i--) {
            commands.get(i).undo();
        }
    }

    @Override
    public String getDescription() {
        return description;
    }
}

/**
 * 调用者：遥控器
 */
public class RemoteControl {
    private Command[] onCommands;
    private Command[] offCommands;
    private Stack<Command> undoStack;
    private List<Command> commandHistory;

    public RemoteControl() {
        onCommands = new Command[7];
        offCommands = new Command[7];
        undoStack = new Stack<>();
        commandHistory = new ArrayList<>();

        Command noCommand = new NoCommand();
        for (int i = 0; i < 7; i++) {
            onCommands[i] = noCommand;
            offCommands[i] = noCommand;
        }
    }

    /**
     * 设置命令
     */
    public void setCommand(int slot, Command onCommand, Command offCommand) {
        onCommands[slot] = onCommand;
        offCommands[slot] = offCommand;
    }

    /**
     * 按下ON按钮
     */
    public void onButtonWasPressed(int slot) {
        System.out.println("\n🔘 按下按钮 " + slot + " (ON)");
        onCommands[slot].execute();
        undoStack.push(onCommands[slot]);
        commandHistory.add(onCommands[slot]);
    }

    /**
     * 按下OFF按钮
     */
    public void offButtonWasPressed(int slot) {
        System.out.println("\n🔘 按下按钮 " + slot + " (OFF)");
        offCommands[slot].execute();
        undoStack.push(offCommands[slot]);
        commandHistory.add(offCommands[slot]);
    }

    /**
     * 撤销按钮
     */
    public void undoButtonWasPressed() {
        System.out.println("\n⏪ 按下撤销按钮");
        if (!undoStack.isEmpty()) {
            Command command = undoStack.pop();
            command.undo();
        } else {
            System.out.println("  ⚠️ 没有可撤销的操作");
        }
    }

    /**
     * 打印遥控器配置
     */
    public void printRemoteConfig() {
        System.out.println("\n========== 遥控器配置 ==========");
        for (int i = 0; i < onCommands.length; i++) {
            System.out.printf("插槽 %d: [ON] %s    [OFF] %s\n", 
                i, 
                onCommands[i].getDescription(),
                offCommands[i].getDescription());
        }
        System.out.println("==============================\n");
    }

    /**
     * 打印命令历史
     */
    public void printCommandHistory() {
        System.out.println("\n========== 命令历史 ==========");
        for (int i = 0; i < commandHistory.size(); i++) {
            System.out.printf("%d. %s\n", i + 1, 
                commandHistory.get(i).getDescription());
        }
        System.out.println("============================\n");
    }
}

/**
 * 使用示例
 */
public class CommandDemo {
    public static void main(String[] args) {
        System.out.println("========== 智能家居遥控器系统 ==========\n");

        // 创建接收者
        Light livingRoomLight = new Light("客厅");
        Light bedroomLight = new Light("卧室");
        AirConditioner ac = new AirConditioner("客厅");
        Stereo stereo = new Stereo("客厅");
        TV tv = new TV("客厅");

        // 创建命令
        Command livingRoomLightOn = new LightOnCommand(livingRoomLight);
        Command livingRoomLightOff = new LightOffCommand(livingRoomLight);
        Command bedroomLightOn = new LightOnCommand(bedroomLight);
        Command bedroomLightOff = new LightOffCommand(bedroomLight);
        Command acOn = new ACOnCommand(ac);
        Command acOff = new ACOffCommand(ac);
        Command stereoOn = new StereoOnCommand(stereo);
        Command stereoOff = new StereoOffCommand(stereo);
        Command tvOn = new TVOnCommand(tv);
        Command tvOff = new LightOffCommand(livingRoomLight); // 示例：复用

        // 创建遥控器
        RemoteControl remote = new RemoteControl();

        // 设置命令到遥控器
        remote.setCommand(0, livingRoomLightOn, livingRoomLightOff);
        remote.setCommand(1, bedroomLightOn, bedroomLightOff);
        remote.setCommand(2, acOn, acOff);
        remote.setCommand(3, stereoOn, stereoOff);
        remote.setCommand(4, tvOn, new NoCommand());

        // 创建宏命令（回家模式）
        List<Command> partyCommands = Arrays.asList(
            livingRoomLightOn,
            new LightDimCommand(livingRoomLight, 80),
            stereoOn,
            acOn,
            new ACSetTemperatureCommand(ac, 24)
        );
        Command partyMode = new MacroCommand(partyCommands, "派对模式");

        // 创建宏命令（离家模式）
        List<Command> allOffCommands = Arrays.asList(
            livingRoomLightOff,
            bedroomLightOff,
            acOff,
            stereoOff
        );
        Command allOffMode = new MacroCommand(allOffCommands, "全部关闭");

        remote.setCommand(5, partyMode, allOffMode);

        // 显示遥控器配置
        remote.printRemoteConfig();

        // 场景1：基本操作
        System.out.println("【场景1】基本操作");
        remote.onButtonWasPressed(0);  // 开客厅灯
        remote.onButtonWasPressed(2);  // 开空调
        remote.onButtonWasPressed(3);  // 开音响

        // 场景2：撤销操作
        System.out.println("\n【场景2】撤销操作");
        remote.undoButtonWasPressed();  // 撤销音响开启
        remote.undoButtonWasPressed();  // 撤销空调开启

        // 场景3：调光命令
        System.out.println("\n【场景3】调光功能");
        Command dimCommand = new LightDimCommand(livingRoomLight, 50);
        remote.setCommand(6, dimCommand, new NoCommand());
        remote.onButtonWasPressed(6);  // 调光到50%
        remote.undoButtonWasPressed();  // 撤销调光

        // 场景4：宏命令（派对模式）
        System.out.println("\n【场景4】派对模式（宏命令）");
        remote.onButtonWasPressed(5);  // 执行派对模式

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 场景5：撤销宏命令
        System.out.println("\n【场景5】撤销派对模式");
        remote.undoButtonWasPressed();  // 撤销整个派对模式

        // 场景6：全部关闭（宏命令）
        System.out.println("\n【场景6】离家模式（全部关闭）");
        remote.offButtonWasPressed(5);  // 执行全部关闭

        // 显示命令历史
        remote.printCommandHistory();

        // 命令模式的优势
        System.out.println("\n========== 命令模式的优势 ==========");
        System.out.println("1. 解耦: 调用者不需要知道接收者的细节");
        System.out.println("2. 撤销/重做: 轻松实现撤销和重做功能");
        System.out.println("3. 宏命令: 可以组合多个命令");
        System.out.println("4. 命令队列: 支持命令排队执行");
        System.out.println("5. 日志记录: 可以记录所有命令历史");
        System.out.println("6. 事务: 支持事务性操作");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. GUI按钮和菜单项");
        System.out.println("2. 文本编辑器的撤销/重做");
        System.out.println("3. 数据库事务管理");
        System.out.println("4. 任务调度系统");
        System.out.println("5. 网络请求重试机制");
        System.out.println("6. 游戏中的操作回放");

        System.out.println("\n========== 如果不使用命令模式 ==========");
        System.out.println("❌ 遥控器直接调用设备:");
        System.out.println("  button1.onClick() { light.on(); }");
        System.out.println("  问题: 无法撤销，无法记录历史，难以扩展");

        System.out.println("\n✅ 使用命令模式:");
        System.out.println("  button1.onClick() { command.execute(); }");
        System.out.println("  优势: 支持撤销，记录历史，易于扩展");
    }
}
```

### 15. 观察者模式（Observer Pattern）

**使用场景**：

* 对象状态变化通知
* 事件驱动系统
* MVC模式
* 消息队列

**好处：**

- 支持松耦合的设计
- 动态订阅/取消订阅
- 支持广播通信
- 符合开闭原则

**解决的问题：**

- 一对多的依赖关系
- 对象状态变化需要通知其他对象
- 发布-订阅场景

**缺点：**

- 可能导致内存泄漏（忘记取消订阅）
- 通知顺序不确定
- 循环依赖问题

**详细案例：股票交易系统**

```java
/**
 * 股票数据
 */
public class StockData {
    private String symbol;      // 股票代码
    private String name;        // 股票名称
    private double price;       // 当前价格
    private double change;      // 涨跌额
    private double changePercent; // 涨跌幅
    private long volume;        // 成交量
    private LocalDateTime updateTime;

    public StockData(String symbol, String name, double price) {
        this.symbol = symbol;
        this.name = name;
        this.price = price;
        this.change = 0;
        this.changePercent = 0;
        this.volume = 0;
        this.updateTime = LocalDateTime.now();
    }

    public void updatePrice(double newPrice, long volume) {
        this.change = newPrice - this.price;
        this.changePercent = (this.change / this.price) * 100;
        this.price = newPrice;
        this.volume += volume;
        this.updateTime = LocalDateTime.now();
    }

    // Getters
    public String getSymbol() { return symbol; }
    public String getName() { return name; }
    public double getPrice() { return price; }
    public double getChange() { return change; }
    public double getChangePercent() { return changePercent; }
    public long getVolume() { return volume; }
    public LocalDateTime getUpdateTime() { return updateTime; }

    @Override
    public String toString() {
        String trend = change >= 0 ? "📈" : "📉";
        return String.format("%s %s(%s) ¥%.2f %s%.2f (%.2f%%)",
            trend, name, symbol, price, 
            change >= 0 ? "+" : "", change, changePercent);
    }
}

/**
 * 观察者接口
 */
public interface Observer {
    void update(StockData stockData);
    String getObserverName();
}

/**
 * 主题接口（被观察者）
 */
public interface Subject {
    void attach(Observer observer);
    void detach(Observer observer);
    void notifyObservers();
}

/**
 * 具体主题：股票市场
 */
public class StockMarket implements Subject {
    private Map<String, StockData> stocks;
    private List<Observer> observers;
    private List<StockData> recentUpdates;

    public StockMarket() {
        this.stocks = new HashMap<>();
        this.observers = new ArrayList<>();
        this.recentUpdates = new ArrayList<>();

        initializeStocks();
    }

    private void initializeStocks() {
        stocks.put("AAPL", new StockData("AAPL", "苹果", 150.00));
        stocks.put("GOOGL", new StockData("GOOGL", "谷歌", 2800.00));
        stocks.put("MSFT", new StockData("MSFT", "微软", 300.00));
        stocks.put("TSLA", new StockData("TSLA", "特斯拉", 700.00));
        stocks.put("BABA", new StockData("BABA", "阿里巴巴", 180.00));
    }

    @Override
    public void attach(Observer observer) {
        if (!observers.contains(observer)) {
            observers.add(observer);
            System.out.println("  ✅ " + observer.getObserverName() + " 已订阅股票行情");
        }
    }

    @Override
    public void detach(Observer observer) {
        if (observers.remove(observer)) {
            System.out.println("  ❌ " + observer.getObserverName() + " 已取消订阅");
        }
    }

    @Override
    public void notifyObservers() {
        if (recentUpdates.isEmpty()) {
            return;
        }

        System.out.println("\n📢 推送股票行情更新给 " + observers.size() + " 个订阅者...");
        for (StockData stock : recentUpdates) {
            for (Observer observer : observers) {
                observer.update(stock);
            }
        }
        recentUpdates.clear();
    }

    /**
     * 更新股票价格
     */
    public void updateStockPrice(String symbol, double newPrice, long volume) {
        StockData stock = stocks.get(symbol);
        if (stock != null) {
            stock.updatePrice(newPrice, volume);
            recentUpdates.add(stock);

            System.out.println("\n💹 股票更新: " + stock);
            notifyObservers();
        }
    }

    public StockData getStock(String symbol) {
        return stocks.get(symbol);
    }

    public int getObserverCount() {
        return observers.size();
    }
}

/**
 * 具体观察者：股票显示屏
 */
public class StockDisplayBoard implements Observer {
    private String name;
    private Map<String, StockData> displayedStocks;

    public StockDisplayBoard(String name) {
        this.name = name;
        this.displayedStocks = new HashMap<>();
    }

    @Override
    public void update(StockData stockData) {
        displayedStocks.put(stockData.getSymbol(), stockData);
        display(stockData);
    }

    private void display(StockData stock) {
        System.out.println("  📊 [" + name + "] 显示: " + stock);
    }

    public void showAllStocks() {
        System.out.println("\n========== " + name + " ==========");
        displayedStocks.values().forEach(stock -> 
            System.out.println("  " + stock));
        System.out.println("================================\n");
    }

    @Override
    public String getObserverName() {
        return name;
    }
}

/**
 * 具体观察者：股票预警系统
 */
public class StockAlertSystem implements Observer {
    private String name;
    private Map<String, Double> priceAlerts;  // 股票代码 -> 预警价格
    private List<String> alertHistory;

    public StockAlertSystem(String name) {
        this.name = name;
        this.priceAlerts = new HashMap<>();
        this.alertHistory = new ArrayList<>();
    }

    /**
     * 设置价格预警
     */
    public void setPriceAlert(String symbol, double targetPrice) {
        priceAlerts.put(symbol, targetPrice);
        System.out.println("  ⚠️ 设置预警: " + symbol + " 目标价 ¥" + targetPrice);
    }

    @Override
    public void update(StockData stockData) {
        String symbol = stockData.getSymbol();

        // 检查价格预警
        if (priceAlerts.containsKey(symbol)) {
            double targetPrice = priceAlerts.get(symbol);
            if (stockData.getPrice() >= targetPrice) {
                String alert = String.format("🚨 [%s] 价格预警！%s 已达到 ¥%.2f (目标 ¥%.2f)",
                    name, stockData.getName(), stockData.getPrice(), targetPrice);
                System.out.println("  " + alert);
                alertHistory.add(alert);
                priceAlerts.remove(symbol);  // 触发后移除预警
            }
        }

        // 检查涨跌幅预警
        if (Math.abs(stockData.getChangePercent()) >= 5) {
            String alert = String.format("🚨 [%s] 异常波动！%s 涨跌幅 %.2f%%",
                name, stockData.getName(), stockData.getChangePercent());
            System.out.println("  " + alert);
            alertHistory.add(alert);
        }
    }

    public void showAlertHistory() {
        System.out.println("\n========== 预警历史 ==========");
        alertHistory.forEach(System.out::println);
        System.out.println("============================\n");
    }

    @Override
    public String getObserverName() {
        return name;
    }
}

/**
 * 具体观察者：投资者
 */
public class Investor implements Observer {
    private String name;
    private Map<String, Integer> portfolio;  // 持仓：股票代码 -> 持有数量
    private double totalValue;
    private List<String> transactions;

    public Investor(String name) {
        this.name = name;
        this.portfolio = new HashMap<>();
        this.totalValue = 0;
        this.transactions = new ArrayList<>();
    }

    /**
     * 买入股票
     */
    public void buyStock(String symbol, int shares) {
        portfolio.put(symbol, portfolio.getOrDefault(symbol, 0) + shares);
        System.out.println("  💰 [" + name + "] 买入 " + symbol + " " + shares + " 股");
    }

    @Override
    public void update(StockData stockData) {
        String symbol = stockData.getSymbol();

        if (portfolio.containsKey(symbol)) {
            int shares = portfolio.get(symbol);
            double value = shares * stockData.getPrice();

            String log = String.format("  💼 [%s] 持仓更新: %s %d股 当前市值 ¥%.2f (%.2f%%)",
                name, symbol, shares, value, stockData.getChangePercent());
            System.out.println(log);

            // 自动交易策略
            if (stockData.getChangePercent() >= 10) {
                System.out.println("    📈 涨幅超过10%，考虑卖出");
            } else if (stockData.getChangePercent() <= -10) {
                System.out.println("    📉 跌幅超过10%，考虑止损");
            }
        }
    }

    @Override
    public String getObserverName() {
        return name + "(投资者)";
    }
}

/**
 * 具体观察者：新闻推送系统
 */
public class NewsPublisher implements Observer {
    private String name;
    private List<String> news;

    public NewsPublisher(String name) {
        this.name = name;
        this.news = new ArrayList<>();
    }

    @Override
    public void update(StockData stockData) {
        // 根据股票变化生成新闻
        if (Math.abs(stockData.getChangePercent()) >= 3) {
            String newsItem = generateNews(stockData);
            news.add(newsItem);
            System.out.println("  📰 [" + name + "] " + newsItem);
        }
    }

    private String generateNews(StockData stock) {
        if (stock.getChangePercent() >= 5) {
            return String.format("快讯：%s 强势上涨%.2f%%，成交活跃",
                stock.getName(), stock.getChangePercent());
        } else if (stock.getChangePercent() <= -5) {
            return String.format("快讯：%s 大幅下跌%.2f%%，投资者需谨慎",
                stock.getName(), stock.getChangePercent());
        } else if (stock.getChangePercent() >= 3) {
            return String.format("%s 表现强劲，涨幅%.2f%%",
                stock.getName(), stock.getChangePercent());
        } else {
            return String.format("%s 走弱，跌幅%.2f%%",
                stock.getName(), stock.getChangePercent());
        }
    }

    @Override
    public String getObserverName() {
        return name;
    }
}

/**
 * 使用示例
 */
public class ObserverDemo {
    public static void main(String[] args) {
        System.out.println("========== 股票交易系统 - 观察者模式 ==========\n");

        // 创建主题
        StockMarket market = new StockMarket();

        // 创建观察者
        StockDisplayBoard mainBoard = new StockDisplayBoard("主显示屏");
        StockDisplayBoard mobileApp = new StockDisplayBoard("手机APP");
        StockAlertSystem alertSystem = new StockAlertSystem("预警系统");
        Investor investor1 = new Investor("张三");
        Investor investor2 = new Investor("李四");
        NewsPublisher newsPublisher = new NewsPublisher("财经新闻");

        // 订阅
        System.out.println("========== 观察者订阅 ==========");
        market.attach(mainBoard);
        market.attach(mobileApp);
        market.attach(alertSystem);
        market.attach(investor1);
        market.attach(investor2);
        market.attach(newsPublisher);

        // 设置预警
        System.out.println("\n========== 设置价格预警 ==========");
        alertSystem.setPriceAlert("AAPL", 155.00);
        alertSystem.setPriceAlert("TSLA", 750.00);

        // 投资者买入股票
        System.out.println("\n========== 投资者建仓 ==========");
        investor1.buyStock("AAPL", 100);
        investor1.buyStock("GOOGL", 50);
        investor2.buyStock("TSLA", 200);
        investor2.buyStock("BABA", 300);

        // 场景1：正常价格波动
        System.out.println("\n========== 场景1：正常交易 ==========");
        market.updateStockPrice("AAPL", 152.00, 1000000);

        sleep(500);

        market.updateStockPrice("GOOGL", 2850.00, 500000);

        sleep(500);

        // 场景2：触发价格预警
        System.out.println("\n========== 场景2：触发价格预警 ==========");
        market.updateStockPrice("AAPL", 156.00, 2000000);

        sleep(500);

        // 场景3：大幅波动
        System.out.println("\n========== 场景3：异常波动 ==========");
        market.updateStockPrice("TSLA", 770.00, 5000000);

        sleep(500);

        market.updateStockPrice("BABA", 162.00, 3000000);

        sleep(500);

        // 场景4：取消订阅
        System.out.println("\n========== 场景4：取消订阅 ==========");
        market.detach(mobileApp);
        market.updateStockPrice("MSFT", 315.00, 1500000);

        // 显示结果
        mainBoard.showAllStocks();
        alertSystem.showAlertHistory();

        // 观察者模式的优势
        System.out.println("\n========== 观察者模式的优势 ==========");
        System.out.println("1. 松耦合: 主题和观察者相互独立");
        System.out.println("2. 动态订阅: 运行时添加/删除观察者");
        System.out.println("3. 广播通信: 一次通知多个观察者");
        System.out.println("4. 符合开闭原则: 新增观察者无需修改主题");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. GUI事件处理（按钮点击）");
        System.out.println("2. 消息队列（发布-订阅）");
        System.out.println("3. 数据绑定（MVC、MVVM）");
        System.out.println("4. 股票行情推送");
        System.out.println("5. 社交媒体通知");
        System.out.println("6. 游戏中的事件系统");

        System.out.println("\n========== Java中的观察者模式 ==========");
        System.out.println("1. java.util.Observer 和 Observable（已废弃）");
        System.out.println("2. PropertyChangeListener");
        System.out.println("3. EventListener");
        System.out.println("4. RxJava（响应式编程）");
        System.out.println("5. Spring的事件机制");

        System.out.println("\n========== 注意事项 ==========");
        System.out.println("⚠️ 1. 避免内存泄漏：记得取消订阅");
        System.out.println("⚠️ 2. 避免循环依赖：观察者和主题互相观察");
        System.out.println("⚠️ 3. 通知顺序不保证：不要依赖通知顺序");
        System.out.println("⚠️ 4. 性能考虑：观察者过多可能影响性能");
    }

    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



我将继续讲解剩余的行为型模式。由于篇幅较长，我会讲解最重要和常用的几个模式。

### 16. 策略模式（Strategy Pattern）

**使用场景**：

* 多种算法变体
* 需要动态切换算法
* 消除条件语句
* 支付方式选择

**好处：**

- 避免多重条件语句
- 算法可以自由切换
- 扩展性好
- 符合开闭原则

**解决的问题：**

- 多个类只有算法不同
- 需要动态选择算法
- 避免暴露复杂的算法实现

**缺点：**

- 策略类数量增加
- 客户端必须了解所有策略

**详细案例：电商促销系统**

```java
/**
 * 订单
 */
public class Order {
    private String orderId;
    private List<OrderItem> items;
    private double totalAmount;
    private String customerLevel;

    public Order(String orderId, String customerLevel) {
        this.orderId = orderId;
        this.customerLevel = customerLevel;
        this.items = new ArrayList<>();
        this.totalAmount = 0;
    }

    public void addItem(OrderItem item) {
        items.add(item);
        totalAmount += item.getSubtotal();
    }

    public String getOrderId() { return orderId; }
    public List<OrderItem> getItems() { return items; }
    public double getTotalAmount() { return totalAmount; }
    public String getCustomerLevel() { return customerLevel; }

    public void printOrder() {
        System.out.println("\n========== 订单详情 ==========");
        System.out.println("订单号: " + orderId);
        System.out.println("客户等级: " + customerLevel);
        System.out.println("商品列表:");
        items.forEach(item -> System.out.println("  " + item));
        System.out.println("订单总额: ¥" + String.format("%.2f", totalAmount));
    }
}

/**
 * 订单项
 */
public class OrderItem {
    private String productName;
    private double price;
    private int quantity;

    public OrderItem(String productName, double price, int quantity) {
        this.productName = productName;
        this.price = price;
        this.quantity = quantity;
    }

    public double getSubtotal() {
        return price * quantity;
    }

    public double getPrice() { return price; }
    public int getQuantity() { return quantity; }

    @Override
    public String toString() {
        return String.format("%s x%d - ¥%.2f", productName, quantity, getSubtotal());
    }
}

/**
 * 促销结果
 */
public class PromotionResult {
    private String strategyName;
    private double originalAmount;
    private double discount;
    private double finalAmount;
    private String description;

    public PromotionResult(String strategyName, double originalAmount, 
                          double discount, String description) {
        this.strategyName = strategyName;
        this.originalAmount = originalAmount;
        this.discount = discount;
        this.finalAmount = originalAmount - discount;
        this.description = description;
    }

    public double getFinalAmount() { return finalAmount; }
    public double getDiscount() { return discount; }

    public void print() {
        System.out.println("========================================");
        System.out.println("促销策略: " + strategyName);
        System.out.println("原价: ¥" + String.format("%.2f", originalAmount));
        System.out.println("优惠: -¥" + String.format("%.2f", discount));
        System.out.println("实付: ¥" + String.format("%.2f", finalAmount));
        System.out.println("说明: " + description);
        System.out.println("========================================\n");
    }
}

/**
 * 策略接口：促销策略
 */
public interface PromotionStrategy {
    PromotionResult calculate(Order order);
    String getStrategyName();
    String getDescription();
}

/**
 * 具体策略：无促销
 */
public class NoPromotionStrategy implements PromotionStrategy {
    @Override
    public PromotionResult calculate(Order order) {
        return new PromotionResult(
            getStrategyName(),
            order.getTotalAmount(),
            0,
            "无优惠活动"
        );
    }

    @Override
    public String getStrategyName() {
        return "无促销";
    }

    @Override
    public String getDescription() {
        return "原价销售";
    }
}

/**
 * 具体策略：满减促销
 */
public class FullReductionStrategy implements PromotionStrategy {
    private double threshold;    // 满减门槛
    private double reduction;    // 减免金额

    public FullReductionStrategy(double threshold, double reduction) {
        this.threshold = threshold;
        this.reduction = reduction;
    }

    @Override
    public PromotionResult calculate(Order order) {
        double total = order.getTotalAmount();
        double discount = 0;
        String desc;

        if (total >= threshold) {
            discount = reduction;
            desc = String.format("满%.0f减%.0f活动已享受", threshold, reduction);
        } else {
            desc = String.format("满%.0f减%.0f，还差¥%.2f", 
                threshold, reduction, threshold - total);
        }

        return new PromotionResult(
            getStrategyName(),
            total,
            discount,
            desc
        );
    }

    @Override
    public String getStrategyName() {
        return String.format("满%.0f减%.0f", threshold, reduction);
    }

    @Override
    public String getDescription() {
        return String.format("订单满%.0f元减%.0f元", threshold, reduction);
    }
}

/**
 * 具体策略：折扣促销
 */
public class DiscountStrategy implements PromotionStrategy {
    private double discountRate;  // 折扣率（0-1）

    public DiscountStrategy(double discountRate) {
        this.discountRate = discountRate;
    }

    @Override
    public PromotionResult calculate(Order order) {
        double total = order.getTotalAmount();
        double discount = total * (1 - discountRate);

        return new PromotionResult(
            getStrategyName(),
            total,
            discount,
            String.format("全场%.1f折优惠", discountRate * 10)
        );
    }

    @Override
    public String getStrategyName() {
        return String.format("%.1f折", discountRate * 10);
    }

    @Override
    public String getDescription() {
        return String.format("全场%.1f折", discountRate * 10);
    }
}

/**
 * 具体策略：会员等级折扣
 */
public class MemberDiscountStrategy implements PromotionStrategy {
    private Map<String, Double> memberDiscounts;

    public MemberDiscountStrategy() {
        this.memberDiscounts = new HashMap<>();
        memberDiscounts.put("普通会员", 0.95);
        memberDiscounts.put("银卡会员", 0.90);
        memberDiscounts.put("金卡会员", 0.85);
        memberDiscounts.put("钻石会员", 0.80);
    }

    @Override
    public PromotionResult calculate(Order order) {
        double total = order.getTotalAmount();
        String level = order.getCustomerLevel();
        double rate = memberDiscounts.getOrDefault(level, 1.0);
        double discount = total * (1 - rate);

        return new PromotionResult(
            getStrategyName(),
            total,
            discount,
            String.format("%s享受%.1f折优惠", level, rate * 10)
        );
    }

    @Override
    public String getStrategyName() {
        return "会员折扣";
    }

    @Override
    public String getDescription() {
        return "根据会员等级享受不同折扣";
    }
}

/**
 * 具体策略：买N送N
 */
public class BuyNGetNStrategy implements PromotionStrategy {
    private int buyCount;
    private int getCount;

    public BuyNGetNStrategy(int buyCount, int getCount) {
        this.buyCount = buyCount;
        this.getCount = getCount;
    }

    @Override
    public PromotionResult calculate(Order order) {
        double total = order.getTotalAmount();
        int totalItems = order.getItems().stream()
            .mapToInt(OrderItem::getQuantity)
            .sum();

        // 计算可以享受的优惠次数
        int sets = totalItems / (buyCount + getCount);

        if (sets > 0) {
            // 简化计算：按平均价格计算赠品价值
            double avgPrice = total / totalItems;
            double discount = sets * getCount * avgPrice;

            return new PromotionResult(
                getStrategyName(),
                total,
                discount,
                String.format("买%d送%d活动，共赠送%d件商品", 
                    buyCount, getCount, sets * getCount)
            );
        }

        return new PromotionResult(
            getStrategyName(),
            total,
            0,
            String.format("买%d送%d活动未达标", buyCount, getCount)
        );
    }

    @Override
    public String getStrategyName() {
        return String.format("买%d送%d", buyCount, getCount);
    }

    @Override
    public String getDescription() {
        return String.format("每买%d件商品送%d件", buyCount, getCount);
    }
}

/**
 * 具体策略：组合策略（可叠加多个策略）
 */
public class ComboPromotionStrategy implements PromotionStrategy {
    private List<PromotionStrategy> strategies;
    private String name;

    public ComboPromotionStrategy(String name, List<PromotionStrategy> strategies) {
        this.name = name;
        this.strategies = strategies;
    }

    @Override
    public PromotionResult calculate(Order order) {
        double total = order.getTotalAmount();
        double totalDiscount = 0;
        StringBuilder desc = new StringBuilder("组合优惠: ");

        for (PromotionStrategy strategy : strategies) {
            PromotionResult result = strategy.calculate(order);
            totalDiscount += result.getDiscount();
            desc.append(strategy.getStrategyName()).append(" + ");
        }

        if (desc.length() > 0) {
            desc.setLength(desc.length() - 3);  // 移除最后的 " + "
        }

        return new PromotionResult(
            name,
            total,
            totalDiscount,
            desc.toString()
        );
    }

    @Override
    public String getStrategyName() {
        return name;
    }

    @Override
    public String getDescription() {
        return "多种促销活动叠加";
    }
}

/**
 * 上下文：促销管理器
 */
public class PromotionContext {
    private PromotionStrategy strategy;

    public PromotionContext(PromotionStrategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(PromotionStrategy strategy) {
        this.strategy = strategy;
    }

    public PromotionResult applyPromotion(Order order) {
        System.out.println("\n🎁 应用促销策略: " + strategy.getStrategyName());
        System.out.println("   " + strategy.getDescription());
        return strategy.calculate(order);
    }
}

/**
 * 策略工厂
 */
public class PromotionStrategyFactory {
    private Map<String, PromotionStrategy> strategies;

    public PromotionStrategyFactory() {
        this.strategies = new HashMap<>();
        initializeStrategies();
    }

    private void initializeStrategies() {
        strategies.put("none", new NoPromotionStrategy());
        strategies.put("full300-50", new FullReductionStrategy(300, 50));
        strategies.put("full500-100", new FullReductionStrategy(500, 100));
        strategies.put("discount20", new DiscountStrategy(0.8));
        strategies.put("discount30", new DiscountStrategy(0.7));
        strategies.put("member", new MemberDiscountStrategy());
        strategies.put("buy2get1", new BuyNGetNStrategy(2, 1));
        strategies.put("buy3get1", new BuyNGetNStrategy(3, 1));
    }

    public PromotionStrategy getStrategy(String key) {
        return strategies.getOrDefault(key, new NoPromotionStrategy());
    }

    public void listAllStrategies() {
        System.out.println("\n========== 可用促销策略 ==========");
        strategies.forEach((key, strategy) -> 
            System.out.println("  " + key + ": " + strategy.getDescription()));
        System.out.println("================================\n");
    }

    /**
     * 根据条件自动选择最优策略
     */
    public PromotionStrategy getBestStrategy(Order order) {
        PromotionStrategy bestStrategy = strategies.get("none");
        double maxDiscount = 0;

        for (PromotionStrategy strategy : strategies.values()) {
            PromotionResult result = strategy.calculate(order);
            if (result.getDiscount() > maxDiscount) {
                maxDiscount = result.getDiscount();
                bestStrategy = strategy;
            }
        }

        return bestStrategy;
    }
}

/**
 * 使用示例
 */
public class StrategyDemo {
    public static void main(String[] args) {
        System.out.println("========== 电商促销系统 - 策略模式 ==========\n");

        // 创建订单
        Order order1 = new Order("ORD001", "金卡会员");
        order1.addItem(new OrderItem("MacBook Pro", 12000, 1));
        order1.addItem(new OrderItem("鼠标", 200, 2));
        order1.addItem(new OrderItem("键盘", 500, 1));
        order1.printOrder();

        // 创建策略工厂
        PromotionStrategyFactory factory = new PromotionStrategyFactory();
        factory.listAllStrategies();

        // 场景1：无促销
        System.out.println("【场景1】无促销策略");
        PromotionContext context = new PromotionContext(factory.getStrategy("none"));
        PromotionResult result1 = context.applyPromotion(order1);
        result1.print();

        // 场景2：满减促销
        System.out.println("【场景2】满减促销");
        context.setStrategy(factory.getStrategy("full300-50"));
        PromotionResult result2 = context.applyPromotion(order1);
        result2.print();

        // 场景3：折扣促销
        System.out.println("【场景3】8折促销");
        context.setStrategy(factory.getStrategy("discount20"));
        PromotionResult result3 = context.applyPromotion(order1);
        result3.print();

        // 场景4：会员折扣
        System.out.println("【场景4】会员折扣");
        context.setStrategy(factory.getStrategy("member"));
        PromotionResult result4 = context.applyPromotion(order1);
        result4.print();

        // 场景5：买2送1
        System.out.println("【场景5】买2送1");
        Order order2 = new Order("ORD002", "普通会员");
        order2.addItem(new OrderItem("T恤", 99, 6));
        order2.printOrder();

        context.setStrategy(factory.getStrategy("buy2get1"));
        PromotionResult result5 = context.applyPromotion(order2);
        result5.print();

        // 场景6：自动选择最优策略
        System.out.println("【场景6】自动选择最优策略");
        PromotionStrategy bestStrategy = factory.getBestStrategy(order1);
        System.out.println("🏆 最优策略: " + bestStrategy.getStrategyName());
        context.setStrategy(bestStrategy);
        PromotionResult result6 = context.applyPromotion(order1);
        result6.print();

        // 场景7：组合策略
        System.out.println("【场景7】组合促销（会员折扣 + 满减）");
        List<PromotionStrategy> comboStrategies = Arrays.asList(
            factory.getStrategy("member"),
            factory.getStrategy("full300-50")
        );
        PromotionStrategy comboStrategy = new ComboPromotionStrategy(
            "双重优惠", comboStrategies);
        context.setStrategy(comboStrategy);
        PromotionResult result7 = context.applyPromotion(order1);
        result7.print();

        // 策略模式的优势
        System.out.println("========== 策略模式的优势 ==========");
        System.out.println("1. 避免if-else: 消除大量条件判断");
        System.out.println("2. 算法独立: 每个策略独立封装");
        System.out.println("3. 易于扩展: 新增策略无需修改原有代码");
        System.out.println("4. 灵活切换: 运行时动态选择策略");

        System.out.println("\n========== 如果不使用策略模式 ==========");
        System.out.println("❌ 需要大量if-else:");
        System.out.println("  if (promotionType.equals(\"满减\")) {");
        System.out.println("    // 满减逻辑");
        System.out.println("  } else if (promotionType.equals(\"折扣\")) {");
        System.out.println("    // 折扣逻辑");
        System.out.println("  } else if ...");
        System.out.println("\n问题:");
        System.out.println("  - 违反开闭原则");
        System.out.println("  - 代码难以维护");
        System.out.println("  - 新增策略需要修改原有代码");

        System.out.println("\n✅ 使用策略模式:");
        System.out.println("  context.setStrategy(new DiscountStrategy(0.8));");
        System.out.println("  result = context.applyPromotion(order);");
        System.out.println("\n优势:");
        System.out.println("  - 代码清晰");
        System.out.println("  - 易于测试");
        System.out.println("  - 符合设计原则");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. 支付方式选择（支付宝、微信、银行卡）");
        System.out.println("2. 排序算法选择（快排、归并、堆排序）");
        System.out.println("3. 压缩算法选择（zip、gzip、7z）");
        System.out.println("4. 路由策略（最短路径、最少时间）");
        System.out.println("5. 数据验证策略");
        System.out.println("6. Spring中的Resource加载策略");
    }
}
```

### 17. 状态模式（State Pattern）

**使用场景**：

* 对象行为随状态改变
* 状态转换复杂
* 条件语句过多
* 工作流引擎

**好处：**

- 避免大量条件判断
- 状态转换逻辑清晰
- 符合开闭原则
- 状态相关行为局部化

**解决的问题：**

- 对象行为随状态改变
- 大量状态相关的条件语句
- 状态转换逻辑复杂

**缺点：**

- 状态类数量增加
- 状态转换分散

**详细案例：订单状态机**

```java
/**
 * 订单实体
 */
public class OrderEntity {
    private String orderId;
    private String productName;
    private double amount;
    private LocalDateTime createTime;
    private String shippingAddress;

    public OrderEntity(String orderId, String productName, 
                      double amount, String shippingAddress) {
        this.orderId = orderId;
        this.productName = productName;
        this.amount = amount;
        this.shippingAddress = shippingAddress;
        this.createTime = LocalDateTime.now();
    }

    public String getOrderId() { return orderId; }
    public String getProductName() { return productName; }
    public double getAmount() { return amount; }
    public String getShippingAddress() { return shippingAddress; }

    @Override
    public String toString() {
        return String.format("订单 %s: %s - ¥%.2f", 
            orderId, productName, amount);
    }
}

/**
 * 状态接口
 */
public interface OrderState {
    void create(OrderContext context);
    void pay(OrderContext context);
    void ship(OrderContext context);
    void deliver(OrderContext context);
    void cancel(OrderContext context);
    void refund(OrderContext context);

    String getStateName();
    String getStateDescription();
}

/**
 * 抽象状态类（提供默认实现）
 */
public abstract class AbstractOrderState implements OrderState {

    @Override
    public void create(OrderContext context) {
        printIllegalOperation("创建订单");
    }

    @Override
    public void pay(OrderContext context) {
        printIllegalOperation("支付");
    }

    @Override
    public void ship(OrderContext context) {
        printIllegalOperation("发货");
    }

    @Override
    public void deliver(OrderContext context) {
        printIllegalOperation("确认收货");
    }

    @Override
    public void cancel(OrderContext context) {
        printIllegalOperation("取消订单");
    }

    @Override
    public void refund(OrderContext context) {
        printIllegalOperation("退款");
    }

    protected void printIllegalOperation(String operation) {
        System.out.println("  ❌ 当前状态[" + getStateName() + 
                         "]不支持操作: " + operation);
    }

    protected void printStateTransition(String from, String to) {
        System.out.println("  🔄 状态转换: " + from + " → " + to);
    }
}

/**
 * 具体状态：待支付
 */
public class PendingPaymentState extends AbstractOrderState {

    @Override
    public void pay(OrderContext context) {
        System.out.println("  💰 正在支付订单...");
        System.out.println("  ✅ 支付成功！");
        printStateTransition(getStateName(), "待发货");
        context.setState(new PendingShipmentState());
    }

    @Override
    public void cancel(OrderContext context) {
        System.out.println("  🚫 取消订单");
        printStateTransition(getStateName(), "已取消");
        context.setState(new CancelledState());
    }

    @Override
    public String getStateName() {
        return "待支付";
    }

    @Override
    public String getStateDescription() {
        return "订单已创建，等待买家付款";
    }
}

/**
 * 具体状态：待发货
 */
public class PendingShipmentState extends AbstractOrderState {

    @Override
    public void ship(OrderContext context) {
        System.out.println("  📦 商家正在打包发货...");
        System.out.println("  🚚 已发货，物流单号: SF1234567890");
        printStateTransition(getStateName(), "待收货");
        context.setState(new ShippedState());
    }

    @Override
    public void refund(OrderContext context) {
        System.out.println("  💸 买家申请退款");
        System.out.println("  ✅ 退款成功");
        printStateTransition(getStateName(), "已退款");
        context.setState(new RefundedState());
    }

    @Override
    public String getStateName() {
        return "待发货";
    }

    @Override
    public String getStateDescription() {
        return "买家已付款，等待商家发货";
    }
}

/**
 * 具体状态：待收货（已发货）
 */
public class ShippedState extends AbstractOrderState {

    @Override
    public void deliver(OrderContext context) {
        System.out.println("  📬 买家确认收货");
        System.out.println("  ✅ 订单完成");
        printStateTransition(getStateName(), "已完成");
        context.setState(new CompletedState());
    }

    @Override
    public void refund(OrderContext context) {
        System.out.println("  📦 买家申请退货退款");
        System.out.println("  🔙 请将商品寄回");
        System.out.println("  ✅ 退款成功");
        printStateTransition(getStateName(), "已退款");
        context.setState(new RefundedState());
    }

    @Override
    public String getStateName() {
        return "待收货";
    }

    @Override
    public String getStateDescription() {
        return "商品已发货，等待买家收货";
    }
}

/**
 * 具体状态：已完成
 */
public class CompletedState extends AbstractOrderState {

    @Override
    public void refund(OrderContext context) {
        System.out.println("  🔄 买家申请售后退款");
        System.out.println("  ⏳ 等待商家审核...");
        System.out.println("  ✅ 售后退款成功");
        printStateTransition(getStateName(), "已退款");
        context.setState(new RefundedState());
    }

    @Override
    public String getStateName() {
        return "已完成";
    }

    @Override
    public String getStateDescription() {
        return "交易完成，买家已确认收货";
    }
}

/**
 * 具体状态：已取消
 */
public class CancelledState extends AbstractOrderState {

    @Override
    public String getStateName() {
        return "已取消";
    }

    @Override
    public String getStateDescription() {
        return "订单已取消";
    }
}

/**
 * 具体状态：已退款
 */
public class RefundedState extends AbstractOrderState {

    @Override
    public String getStateName() {
        return "已退款";
    }

    @Override
    public String getStateDescription() {
        return "订单已退款";
    }
}

/**
 * 上下文：订单上下文
 */
public class OrderContext {
    private OrderEntity order;
    private OrderState currentState;
    private List<String> stateHistory;

    public OrderContext(OrderEntity order) {
        this.order = order;
        this.currentState = new PendingPaymentState();
        this.stateHistory = new ArrayList<>();
        recordState();
    }

    public void setState(OrderState state) {
        this.currentState = state;
        recordState();
    }

    private void recordState() {
        String record = String.format("[%s] %s - %s",
            LocalDateTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss")),
            currentState.getStateName(),
            currentState.getStateDescription());
        stateHistory.add(record);
    }

    // 委托给当前状态处理
    public void pay() {
        System.out.println("\n🔔 执行操作: 支付");
        currentState.pay(this);
    }

    public void ship() {
        System.out.println("\n🔔 执行操作: 发货");
        currentState.ship(this);
    }

    public void deliver() {
        System.out.println("\n🔔 执行操作: 确认收货");
        currentState.deliver(this);
    }

    public void cancel() {
        System.out.println("\n🔔 执行操作: 取消订单");
        currentState.cancel(this);
    }

    public void refund() {
        System.out.println("\n🔔 执行操作: 退款");
        currentState.refund(this);
    }

    public String getCurrentStateName() {
        return currentState.getStateName();
    }

    public void printOrderInfo() {
        System.out.println("\n========================================");
        System.out.println(order);
        System.out.println("收货地址: " + order.getShippingAddress());
        System.out.println("当前状态: " + currentState.getStateName());
        System.out.println("状态说明: " + currentState.getStateDescription());
        System.out.println("========================================");
    }

    public void printStateHistory() {
        System.out.println("\n========== 订单状态历史 ==========");
        stateHistory.forEach(System.out::println);
        System.out.println("================================\n");
    }
}

/**
 * 使用示例
 */
public class StateDemo {
    public static void main(String[] args) {
        System.out.println("========== 订单状态机 - 状态模式 ==========\n");

        // 场景1：正常的订单流程
        System.out.println("【场景1】正常订单流程：创建 → 支付 → 发货 → 收货");
        OrderEntity order1 = new OrderEntity(
            "ORD001", "iPhone 15 Pro", 8999, "北京市朝阳区XX街道");
        OrderContext context1 = new OrderContext(order1);
        context1.printOrderInfo();

        context1.pay();
        context1.printOrderInfo();

        context1.ship();
        context1.printOrderInfo();

        context1.deliver();
        context1.printOrderInfo();

        context1.printStateHistory();

        // 场景2：未支付就取消
        System.out.println("\n【场景2】未支付就取消订单");
        OrderEntity order2 = new OrderEntity(
            "ORD002", "MacBook Pro", 12999, "上海市浦东新区XX路");
        OrderContext context2 = new OrderContext(order2);
        context2.printOrderInfo();

        context2.cancel();
        context2.printOrderInfo();

        // 尝试对已取消的订单进行支付
        context2.pay();

        // 场景3：支付后申请退款
        System.out.println("\n【场景3】支付后未发货申请退款");
        OrderEntity order3 = new OrderEntity(
            "ORD003", "iPad Air", 4599, "广州市天河区XX街");
        OrderContext context3 = new OrderContext(order3);

        context3.pay();
        context3.refund();
        context3.printOrderInfo();

        // 场景4：发货后申请退款
        System.out.println("\n【场景4】收到货后申请退款");
        OrderEntity order4 = new OrderEntity(
            "ORD004", "AirPods Pro", 1999, "深圳市南山区XX大道");
        OrderContext context4 = new OrderContext(order4);

        context4.pay();
        context4.ship();
        context4.deliver();
        context4.refund();  // 售后退款
        context4.printOrderInfo();

        context4.printStateHistory();

        // 场景5：非法操作
        System.out.println("\n【场景5】非法操作示例");
        OrderEntity order5 = new OrderEntity(
            "ORD005", "Apple Watch", 3199, "杭州市西湖区XX路");
        OrderContext context5 = new OrderContext(order5);

        context5.ship();    // 未支付不能发货
        context5.deliver(); // 未支付不能确认收货

        // 状态模式的优势
        System.out.println("\n========== 状态模式的优势 ==========");
        System.out.println("1. 消除条件语句: 避免大量if-else");
        System.out.println("2. 状态封装: 每个状态独立管理");
        System.out.println("3. 状态转换清晰: 转换逻辑在状态类中");
        System.out.println("4. 易于扩展: 新增状态无需修改原有代码");

        System.out.println("\n========== 如果不使用状态模式 ==========");
        System.out.println("❌ 需要大量状态判断:");
        System.out.println("  if (state == PENDING_PAYMENT) {");
        System.out.println("    if (operation == PAY) { ... }");
        System.out.println("    else if (operation == CANCEL) { ... }");
        System.out.println("  } else if (state == PENDING_SHIPMENT) {");
        System.out.println("    if (operation == SHIP) { ... }");
        System.out.println("    else if (operation == REFUND) { ... }");
        System.out.println("  } ...");
        System.out.println("\n问题:");
        System.out.println("  - 代码臃肿难以维护");
        System.out.println("  - 状态转换逻辑分散");
        System.out.println("  - 违反开闭原则");

        System.out.println("\n✅ 使用状态模式:");
        System.out.println("  context.pay();  // 状态对象处理");
        System.out.println("\n优势:");
        System.out.println("  - 代码清晰");
        System.out.println("  - 状态独立");
        System.out.println("  - 易于扩展");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. 订单状态管理");
        System.out.println("2. TCP连接状态");
        System.out.println("3. 游戏角色状态（站立、行走、跳跃、攻击）");
        System.out.println("4. 工作流引擎");
        System.out.println("5. 视频播放器状态（播放、暂停、停止）");
        System.out.println("6. 电梯运行状态");

        System.out.println("\n========== 状态模式 vs 策略模式 ==========");
        System.out.println("状态模式:");
        System.out.println("  - 封装对象的状态");
        System.out.println("  - 状态会自动转换");
        System.out.println("  - 状态之间有依赖关系");

        System.out.println("\n策略模式:");
        System.out.println("  - 封装算法");
        System.out.println("  - 由客户端选择策略");
        System.out.println("  - 策略之间相互独立");
    }
}
```



### 18. 模板方法模式（Template Method Pattern）

**使用场景**：

* 算法框架固定
* 子步骤可变
* 代码复用
* 框架设计

**好处：**

- 封装不变部分，扩展可变部分
- 提取公共代码，便于维护
- 行为由父类控制，子类实现
- 符合开闭原则

**解决的问题：**

- 多个类有相似的执行流程
- 算法骨架固定，细节可变
- 避免代码重复

**缺点：**

- 每个实现都需要一个子类
- 增加系统复杂度

**详细案例：数据采集系统**

```java
/**
 * 数据记录
 */
public class DataRecord {
    private String source;
    private Map<String, Object> data;
    private LocalDateTime timestamp;

    public DataRecord(String source) {
        this.source = source;
        this.data = new HashMap<>();
        this.timestamp = LocalDateTime.now();
    }

    public void addField(String key, Object value) {
        data.put(key, value);
    }

    public String getSource() { return source; }
    public Map<String, Object> getData() { return data; }
    public LocalDateTime getTimestamp() { return timestamp; }

    @Override
    public String toString() {
        return String.format("[%s] %s - %s", 
            timestamp.format(DateTimeFormatter.ofPattern("HH:mm:ss")),
            source, data);
    }
}

/**
 * 抽象类：数据采集器（模板方法模式）
 */
public abstract class DataCollector {

    /**
     * 模板方法：定义数据采集的算法骨架
     */
    public final List<DataRecord> collect() {
        System.out.println("\n========== 开始数据采集 ==========");
        System.out.println("数据源: " + getDataSourceName());

        // 1. 连接数据源
        if (!connect()) {
            System.out.println("❌ 连接失败，采集中止");
            return new ArrayList<>();
        }

        // 2. 验证权限
        if (!authenticate()) {
            System.out.println("❌ 认证失败，采集中止");
            disconnect();
            return new ArrayList<>();
        }

        // 3. 提取数据
        List<DataRecord> rawData = extractData();
        System.out.println("✅ 提取到 " + rawData.size() + " 条原始数据");

        // 4. 转换数据
        List<DataRecord> transformedData = transformData(rawData);
        System.out.println("✅ 转换后 " + transformedData.size() + " 条数据");

        // 5. 验证数据
        List<DataRecord> validData = validateData(transformedData);
        System.out.println("✅ 验证通过 " + validData.size() + " 条数据");

        // 6. 保存数据
        saveData(validData);

        // 7. 清理资源
        cleanup();

        // 8. 断开连接
        disconnect();

        System.out.println("========== 采集完成 ==========\n");

        return validData;
    }

    // 抽象方法：子类必须实现
    protected abstract boolean connect();
    protected abstract List<DataRecord> extractData();

    // 钩子方法：子类可选择性覆盖
    protected boolean authenticate() {
        System.out.println("  🔓 使用默认认证方式");
        return true;
    }

    protected List<DataRecord> transformData(List<DataRecord> rawData) {
        System.out.println("  🔄 使用默认数据转换");
        return rawData;
    }

    protected List<DataRecord> validateData(List<DataRecord> data) {
        System.out.println("  ✓ 使用默认数据验证");
        return data;
    }

    protected void saveData(List<DataRecord> data) {
        System.out.println("  💾 保存数据到默认存储");
        data.forEach(record -> System.out.println("    " + record));
    }

    protected void cleanup() {
        System.out.println("  🧹 清理临时资源");
    }

    protected void disconnect() {
        System.out.println("  🔌 断开连接");
    }

    // 获取数据源名称
    protected abstract String getDataSourceName();
}

/**
 * 具体类：MySQL数据采集器
 */
public class MySQLCollector extends DataCollector {
    private String host;
    private int port;
    private String database;
    private String username;
    private String password;
    private boolean connected = false;

    public MySQLCollector(String host, int port, String database, 
                         String username, String password) {
        this.host = host;
        this.port = port;
        this.database = database;
        this.username = username;
        this.password = password;
    }

    @Override
    protected boolean connect() {
        System.out.println("  🔗 连接到MySQL数据库");
        System.out.println("    地址: " + host + ":" + port);
        System.out.println("    数据库: " + database);

        // 模拟连接
        try {
            Thread.sleep(100);
            connected = true;
            System.out.println("  ✅ MySQL连接成功");
            return true;
        } catch (InterruptedException e) {
            return false;
        }
    }

    @Override
    protected boolean authenticate() {
        System.out.println("  🔐 MySQL身份验证");
        System.out.println("    用户名: " + username);

        // 模拟认证
        if (username != null && password != null) {
            System.out.println("  ✅ 认证成功");
            return true;
        }
        return false;
    }

    @Override
    protected List<DataRecord> extractData() {
        System.out.println("  📊 执行SQL查询: SELECT * FROM users");

        // 模拟从数据库提取数据
        List<DataRecord> records = new ArrayList<>();
        for (int i = 1; i <= 5; i++) {
            DataRecord record = new DataRecord("MySQL");
            record.addField("id", i);
            record.addField("name", "User" + i);
            record.addField("email", "user" + i + "@example.com");
            records.add(record);
        }

        return records;
    }

    @Override
    protected List<DataRecord> validateData(List<DataRecord> data) {
        System.out.println("  ✓ MySQL数据验证（检查非空字段）");

        List<DataRecord> validData = new ArrayList<>();
        for (DataRecord record : data) {
            Map<String, Object> fields = record.getData();
            if (fields.containsKey("id") && fields.containsKey("name")) {
                validData.add(record);
            } else {
                System.out.println("    ⚠️ 跳过无效记录");
            }
        }

        return validData;
    }

    @Override
    protected String getDataSourceName() {
        return "MySQL数据库";
    }
}

/**
 * 具体类：CSV文件采集器
 */
public class CSVCollector extends DataCollector {
    private String filePath;
    private boolean fileOpened = false;

    public CSVCollector(String filePath) {
        this.filePath = filePath;
    }

    @Override
    protected boolean connect() {
        System.out.println("  📁 打开CSV文件");
        System.out.println("    路径: " + filePath);

        // 模拟打开文件
        try {
            Thread.sleep(50);
            fileOpened = true;
            System.out.println("  ✅ 文件打开成功");
            return true;
        } catch (InterruptedException e) {
            return false;
        }
    }

    @Override
    protected boolean authenticate() {
        // CSV文件不需要认证，使用默认实现
        System.out.println("  ✓ CSV文件无需认证");
        return true;
    }

    @Override
    protected List<DataRecord> extractData() {
        System.out.println("  📄 读取CSV文件内容");

        // 模拟读取CSV数据
        List<DataRecord> records = new ArrayList<>();
        String[] headers = {"id", "product", "price", "quantity"};

        for (int i = 1; i <= 3; i++) {
            DataRecord record = new DataRecord("CSV");
            record.addField("id", "P" + i);
            record.addField("product", "Product" + i);
            record.addField("price", 99.99 * i);
            record.addField("quantity", i * 10);
            records.add(record);
        }

        return records;
    }

    @Override
    protected List<DataRecord> transformData(List<DataRecord> rawData) {
        System.out.println("  🔄 CSV数据转换（价格格式化）");

        for (DataRecord record : rawData) {
            Object price = record.getData().get("price");
            if (price instanceof Double) {
                record.addField("price", String.format("%.2f", price));
            }
        }

        return rawData;
    }

    @Override
    protected String getDataSourceName() {
        return "CSV文件";
    }
}

/**
 * 具体类：API数据采集器
 */
public class APICollector extends DataCollector {
    private String apiUrl;
    private String apiKey;
    private boolean connected = false;

    public APICollector(String apiUrl, String apiKey) {
        this.apiUrl = apiUrl;
        this.apiKey = apiKey;
    }

    @Override
    protected boolean connect() {
        System.out.println("  🌐 连接到API");
        System.out.println("    URL: " + apiUrl);

        // 模拟HTTP连接
        try {
            Thread.sleep(100);
            connected = true;
            System.out.println("  ✅ API连接成功");
            return true;
        } catch (InterruptedException e) {
            return false;
        }
    }

    @Override
    protected boolean authenticate() {
        System.out.println("  🔑 API密钥验证");
        System.out.println("    API Key: " + apiKey.substring(0, 8) + "...");

        if (apiKey != null && !apiKey.isEmpty()) {
            System.out.println("  ✅ API认证成功");
            return true;
        }
        return false;
    }

    @Override
    protected List<DataRecord> extractData() {
        System.out.println("  📡 发送API请求: GET " + apiUrl);

        // 模拟API响应
        List<DataRecord> records = new ArrayList<>();
        for (int i = 1; i <= 4; i++) {
            DataRecord record = new DataRecord("API");
            record.addField("userId", i);
            record.addField("username", "ApiUser" + i);
            record.addField("status", "active");
            record.addField("lastLogin", LocalDateTime.now().minusDays(i));
            records.add(record);
        }

        return records;
    }

    @Override
    protected List<DataRecord> transformData(List<DataRecord> rawData) {
        System.out.println("  🔄 API数据转换（时间格式化）");

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        for (DataRecord record : rawData) {
            Object lastLogin = record.getData().get("lastLogin");
            if (lastLogin instanceof LocalDateTime) {
                record.addField("lastLogin", ((LocalDateTime) lastLogin).format(formatter));
            }
        }

        return rawData;
    }

    @Override
    protected List<DataRecord> validateData(List<DataRecord> data) {
        System.out.println("  ✓ API数据验证（检查必需字段和状态）");

        List<DataRecord> validData = new ArrayList<>();
        for (DataRecord record : data) {
            Map<String, Object> fields = record.getData();
            if (fields.containsKey("userId") && 
                fields.containsKey("username") &&
                "active".equals(fields.get("status"))) {
                validData.add(record);
            } else {
                System.out.println("    ⚠️ 跳过无效或非活跃用户");
            }
        }

        return validData;
    }

    @Override
    protected void cleanup() {
        System.out.println("  🧹 清理HTTP连接池");
    }

    @Override
    protected String getDataSourceName() {
        return "REST API";
    }
}

/**
 * 具体类：Excel文件采集器
 */
public class ExcelCollector extends DataCollector {
    private String filePath;
    private String sheetName;

    public ExcelCollector(String filePath, String sheetName) {
        this.filePath = filePath;
        this.sheetName = sheetName;
    }

    @Override
    protected boolean connect() {
        System.out.println("  📊 打开Excel文件");
        System.out.println("    路径: " + filePath);
        System.out.println("    工作表: " + sheetName);

        try {
            Thread.sleep(80);
            System.out.println("  ✅ Excel文件打开成功");
            return true;
        } catch (InterruptedException e) {
            return false;
        }
    }

    @Override
    protected List<DataRecord> extractData() {
        System.out.println("  📈 读取Excel工作表数据");

        List<DataRecord> records = new ArrayList<>();
        for (int i = 1; i <= 6; i++) {
            DataRecord record = new DataRecord("Excel");
            record.addField("rowNum", i);
            record.addField("department", "Dept" + (i % 3 + 1));
            record.addField("employee", "Employee" + i);
            record.addField("salary", 5000 + i * 1000);
            records.add(record);
        }

        return records;
    }

    @Override
    protected List<DataRecord> transformData(List<DataRecord> rawData) {
        System.out.println("  🔄 Excel数据转换（添加计算字段）");

        for (DataRecord record : rawData) {
            Object salary = record.getData().get("salary");
            if (salary instanceof Integer) {
                int annualSalary = (Integer) salary * 12;
                record.addField("annualSalary", annualSalary);
            }
        }

        return rawData;
    }

    @Override
    protected String getDataSourceName() {
        return "Excel文件";
    }
}

/**
 * 使用示例
 */
public class TemplateMethodDemo {
    public static void main(String[] args) {
        System.out.println("========== 数据采集系统 - 模板方法模式 ==========\n");

        List<DataCollector> collectors = new ArrayList<>();

        // 场景1：MySQL数据采集
        System.out.println("【场景1】MySQL数据库采集");
        DataCollector mysqlCollector = new MySQLCollector(
            "localhost", 3306, "mydb", "root", "password");
        collectors.add(mysqlCollector);
        mysqlCollector.collect();

        // 场景2：CSV文件采集
        System.out.println("【场景2】CSV文件采集");
        DataCollector csvCollector = new CSVCollector("data/products.csv");
        collectors.add(csvCollector);
        csvCollector.collect();

        // 场景3：API数据采集
        System.out.println("【场景3】REST API采集");
        DataCollector apiCollector = new APICollector(
            "https://api.example.com/users", "sk_test_123456789abcdef");
        collectors.add(apiCollector);
        apiCollector.collect();

        // 场景4：Excel文件采集
        System.out.println("【场景4】Excel文件采集");
        DataCollector excelCollector = new ExcelCollector(
            "data/employees.xlsx", "Sheet1");
        collectors.add(excelCollector);
        excelCollector.collect();

        // 模板方法模式的优势
        System.out.println("========== 模板方法模式的优势 ==========");
        System.out.println("1. 代码复用: 公共流程在父类中实现");
        System.out.println("2. 控制反转: 父类调用子类方法（好莱坞原则）");
        System.out.println("3. 扩展性好: 新增数据源只需继承实现");
        System.out.println("4. 符合开闭原则: 不修改模板，扩展子类");

        System.out.println("\n========== 如果不使用模板方法模式 ==========");
        System.out.println("❌ 每个采集器都重复实现完整流程:");
        System.out.println("  class MySQLCollector {");
        System.out.println("    collect() {");
        System.out.println("      connect(); authenticate();");
        System.out.println("      extract(); transform(); validate();");
        System.out.println("      save(); cleanup(); disconnect();");
        System.out.println("    }");
        System.out.println("  }");
        System.out.println("  class CSVCollector { /* 重复相同流程 */ }");
        System.out.println("\n问题: 大量重复代码，难以维护");

        System.out.println("\n✅ 使用模板方法模式:");
        System.out.println("  abstract class DataCollector {");
        System.out.println("    final collect() { /* 定义流程 */ }");
        System.out.println("    abstract extractData(); /* 子类实现 */");
        System.out.println("  }");
        System.out.println("\n优势: 流程统一，只需实现差异部分");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. Servlet的service()方法");
        System.out.println("2. Spring的JdbcTemplate");
        System.out.println("3. JUnit的setUp()和tearDown()");
        System.out.println("4. 数据采集框架");
        System.out.println("5. 文档生成器（PDF、Word、HTML）");
        System.out.println("6. 游戏AI行为树");

        System.out.println("\n========== 钩子方法的作用 ==========");
        System.out.println("钩子方法（Hook Method）提供默认实现，子类可选择性覆盖:");
        System.out.println("  - authenticate(): 默认认证方式");
        System.out.println("  - transformData(): 默认数据转换");
        System.out.println("  - validateData(): 默认数据验证");
        System.out.println("子类可以根据需要覆盖这些方法，提供特定实现");

        System.out.println("\n========== 好莱坞原则 ==========");
        System.out.println("\"Don't call us, we'll call you\"");
        System.out.println("父类（高层）调用子类（低层）的方法");
        System.out.println("控制权在父类，子类只负责实现细节");
    }
}
```

### 19. 迭代器模式（Iterator Pattern）

**使用场景**：

* 访问聚合对象内容
* 支持多种遍历方式
* 统一遍历接口

**好处：**

- 提供统一的遍历接口
- 支持不同的遍历方式
- 封装内部结构
- 简化聚合类

**解决的问题：**

- 需要遍历聚合对象
- 不暴露内部结构
- 支持多种遍历方式

**缺点：**

- 增加类的数量
- 对于简单集合可能过度设计

**详细案例：书籍管理系统**

```java
/**
 * 书籍实体
 */
public class Book {
    private String isbn;
    private String title;
    private String author;
    private String category;
    private double price;
    private int publishYear;

    public Book(String isbn, String title, String author, 
                String category, double price, int publishYear) {
        this.isbn = isbn;
        this.title = title;
        this.author = author;
        this.category = category;
        this.price = price;
        this.publishYear = publishYear;
    }

    public String getIsbn() { return isbn; }
    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public String getCategory() { return category; }
    public double getPrice() { return price; }
    public int getPublishYear() { return publishYear; }

    @Override
    public String toString() {
        return String.format("《%s》- %s (%s) ¥%.2f",
            title, author, category, price);
    }
}

/**
 * 迭代器接口
 */
public interface Iterator<T> {
    boolean hasNext();
    T next();
    void reset();
}

/**
 * 聚合接口
 */
public interface Aggregate<T> {
    Iterator<T> createIterator();
}

/**
 * 具体迭代器：顺序迭代器
 */
public class SequentialIterator implements Iterator<Book> {
    private List<Book> books;
    private int position;

    public SequentialIterator(List<Book> books) {
        this.books = books;
        this.position = 0;
    }

    @Override
    public boolean hasNext() {
        return position < books.size();
    }

    @Override
    public Book next() {
        if (!hasNext()) {
            throw new NoSuchElementException("没有更多书籍");
        }
        return books.get(position++);
    }

    @Override
    public void reset() {
        position = 0;
    }
}

/**
 * 具体迭代器：逆序迭代器
 */
public class ReverseIterator implements Iterator<Book> {
    private List<Book> books;
    private int position;

    public ReverseIterator(List<Book> books) {
        this.books = books;
        this.position = books.size() - 1;
    }

    @Override
    public boolean hasNext() {
        return position >= 0;
    }

    @Override
    public Book next() {
        if (!hasNext()) {
            throw new NoSuchElementException("没有更多书籍");
        }
        return books.get(position--);
    }

    @Override
    public void reset() {
        position = books.size() - 1;
    }
}

/**
 * 具体迭代器：分类过滤迭代器
 */
public class CategoryFilterIterator implements Iterator<Book> {
    private List<Book> books;
    private String category;
    private int position;

    public CategoryFilterIterator(List<Book> books, String category) {
        this.books = books;
        this.category = category;
        this.position = 0;
        findNextMatch();
    }

    @Override
    public boolean hasNext() {
        return position < books.size();
    }

    @Override
    public Book next() {
        if (!hasNext()) {
            throw new NoSuchElementException("没有更多 " + category + " 类别的书籍");
        }

        Book book = books.get(position++);
        findNextMatch();
        return book;
    }

    private void findNextMatch() {
        while (position < books.size() && 
               !books.get(position).getCategory().equals(category)) {
            position++;
        }
    }

    @Override
    public void reset() {
        position = 0;
        findNextMatch();
    }
}

/**
 * 具体迭代器：价格范围迭代器
 */
public class PriceRangeIterator implements Iterator<Book> {
    private List<Book> books;
    private double minPrice;
    private double maxPrice;
    private int position;

    public PriceRangeIterator(List<Book> books, double minPrice, double maxPrice) {
        this.books = books;
        this.minPrice = minPrice;
        this.maxPrice = maxPrice;
        this.position = 0;
        findNextMatch();
    }

    @Override
    public boolean hasNext() {
        return position < books.size();
    }

    @Override
    public Book next() {
        if (!hasNext()) {
            throw new NoSuchElementException("没有更多符合价格范围的书籍");
        }

        Book book = books.get(position++);
        findNextMatch();
        return book;
    }

    private void findNextMatch() {
        while (position < books.size()) {
            Book book = books.get(position);
            if (book.getPrice() >= minPrice && book.getPrice() <= maxPrice) {
                break;
            }
            position++;
        }
    }

    @Override
    public void reset() {
        position = 0;
        findNextMatch();
    }
}

/**
 * 具体聚合：书籍集合
 */
public class BookCollection implements Aggregate<Book> {
    private List<Book> books;

    public BookCollection() {
        this.books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
        System.out.println("  ➕ 添加书籍: " + book);
    }

    public void removeBook(Book book) {
        books.remove(book);
    }

    public int size() {
        return books.size();
    }

    @Override
    public Iterator<Book> createIterator() {
        return new SequentialIterator(books);
    }

    /**
     * 创建逆序迭代器
     */
    public Iterator<Book> createReverseIterator() {
        return new ReverseIterator(books);
    }

    /**
     * 创建分类过滤迭代器
     */
    public Iterator<Book> createCategoryIterator(String category) {
        return new CategoryFilterIterator(books, category);
    }

    /**
     * 创建价格范围迭代器
     */
    public Iterator<Book> createPriceRangeIterator(double minPrice, double maxPrice) {
        return new PriceRangeIterator(books, minPrice, maxPrice);
    }
}

/**
 * 使用示例
 */
public class IteratorDemo {
    public static void main(String[] args) {
        System.out.println("========== 书籍管理系统 - 迭代器模式 ==========\n");

        // 创建书籍集合
        BookCollection collection = new BookCollection();

        System.out.println("【初始化】添加书籍到集合");
        collection.addBook(new Book("978-1", "设计模式", "GoF", "技术", 89.00, 1994));
        collection.addBook(new Book("978-2", "Java编程思想", "Bruce Eckel", "技术", 108.00, 2006));
        collection.addBook(new Book("978-3", "三体", "刘慈欣", "科幻", 68.00, 2008));
        collection.addBook(new Book("978-4", "活着", "余华", "文学", 45.00, 1992));
        collection.addBook(new Book("978-5", "Effective Java", "Joshua Bloch", "技术", 99.00, 2018));
        collection.addBook(new Book("978-6", "百年孤独", "马尔克斯", "文学", 55.00, 1967));
        collection.addBook(new Book("978-7", "流浪地球", "刘慈欣", "科幻", 42.00, 2000));
        collection.addBook(new Book("978-8", "Spring实战", "Craig Walls", "技术", 79.00, 2020));

        System.out.println("\n总共 " + collection.size() + " 本书\n");

        // 场景1：顺序遍历
        System.out.println("【场景1】顺序遍历所有书籍");
        Iterator<Book> sequentialIterator = collection.createIterator();
        int count = 1;
        while (sequentialIterator.hasNext()) {
            System.out.println("  " + count++ + ". " + sequentialIterator.next());
        }

        // 场景2：逆序遍历
        System.out.println("\n【场景2】逆序遍历所有书籍");
        Iterator<Book> reverseIterator = collection.createReverseIterator();
        count = 1;
        while (reverseIterator.hasNext()) {
            System.out.println("  " + count++ + ". " + reverseIterator.next());
        }

        // 场景3：按分类遍历
        System.out.println("\n【场景3】只遍历技术类书籍");
        Iterator<Book> techIterator = collection.createCategoryIterator("技术");
        count = 1;
        while (techIterator.hasNext()) {
            System.out.println("  " + count++ + ". " + techIterator.next());
        }

        System.out.println("\n【场景4】只遍历文学类书籍");
        Iterator<Book> literatureIterator = collection.createCategoryIterator("文学");
        count = 1;
        while (literatureIterator.hasNext()) {
            System.out.println("  " + count++ + ". " + literatureIterator.next());
        }

        // 场景5：按价格范围遍历
        System.out.println("\n【场景5】遍历价格在50-100元的书籍");
        Iterator<Book> priceIterator = collection.createPriceRangeIterator(50, 100);
        count = 1;
        while (priceIterator.hasNext()) {
            System.out.println("  " + count++ + ". " + priceIterator.next());
        }

        // 场景6：重置迭代器
        System.out.println("\n【场景6】重置迭代器重新遍历");
        Iterator<Book> iterator = collection.createCategoryIterator("科幻");
        System.out.println("第一次遍历:");
        while (iterator.hasNext()) {
            System.out.println("  " + iterator.next());
        }

        System.out.println("\n重置后再次遍历:");
        iterator.reset();
        while (iterator.hasNext()) {
            System.out.println("  " + iterator.next());
        }

        // 迭代器模式的优势
        System.out.println("\n========== 迭代器模式的优势 ==========");
        System.out.println("1. 统一接口: 提供统一的遍历方式");
        System.out.println("2. 封装性: 不暴露集合内部结构");
        System.out.println("3. 多样性: 支持多种遍历方式");
        System.out.println("4. 单一职责: 分离遍历逻辑和业务逻辑");

        System.out.println("\n========== 实际应用 ==========");
        System.out.println("1. Java集合框架（Iterator接口）");
        System.out.println("2. 数据库结果集（ResultSet）");
        System.out.println("3. 文件遍历");
        System.out.println("4. 树形结构遍历（深度优先、广度优先）");
        System.out.println("5. 图的遍历");

        System.out.println("\n========== Java中的迭代器 ==========");
        System.out.println("Java集合框架已内置迭代器:");
        System.out.println("  List<String> list = new ArrayList<>();");
        System.out.println("  Iterator<String> it = list.iterator();");
        System.out.println("  while (it.hasNext()) {");
        System.out.println("    String item = it.next();");
        System.out.println("  }");

        System.out.println("\n增强for循环底层使用迭代器:");
        System.out.println("  for (String item : list) {");
        System.out.println("    // 编译器自动转换为迭代器");
        System.out.println("  }");

        System.out.println("\n========== 迭代器模式的价值 ==========");
        System.out.println("虽然Java已提供Iterator，但自定义迭代器可以:");
        System.out.println("  ✓ 实现特殊的遍历逻辑（过滤、排序）");
        System.out.println("  ✓ 支持多种遍历方式（正序、逆序）");
        System.out.println("  ✓ 实现延迟加载");
        System.out.println("  ✓ 实现组合遍历");
    }
}
```



我将继续讲解最后3个行为型模式。

### 20. 中介者模式（Mediator Pattern）

**使用场景**：

* 对象间交互复杂
* 聊天室
* 机场调度系统
* MVC控制器

**好处：**

- 降低类之间的耦合
- 将多对多转换为一对多
- 集中控制交互逻辑
- 符合迪米特法则

**解决的问题：**

- 对象之间存在复杂的引用关系
- 多个对象之间需要相互通信
- 对象间的交互逻辑复杂

**缺点：**

- 中介者可能变得复杂
- 中介者本身难以维护

**详细案例：聊天室系统**

```java
/**
 * 用户
 */
public class User {
    private String id;
    private String name;
    private ChatMediator mediator;
    private boolean online;
    private List<String> messageHistory;

    public User(String id, String name) {
        this.id = id;
        this.name = name;
        this.online = false;
        this.messageHistory = new ArrayList<>();
    }

    public void setMediator(ChatMediator mediator) {
        this.mediator = mediator;
    }

    public void login() {
        online = true;
        System.out.println("  ✅ " + name + " 已上线");
    }

    public void logout() {
        online = false;
        System.out.println("  ⬇️ " + name + " 已下线");
    }

    /**
     * 发送消息给指定用户
     */
    public void sendMessage(String targetUserId, String message) {
        if (!online) {
            System.out.println("  ❌ " + name + " 未登录，无法发送消息");
            return;
        }

        System.out.println("  📤 " + name + " 发送消息给 " + targetUserId + ": " + message);
        mediator.sendMessage(this.id, targetUserId, message);
    }

    /**
     * 群发消息
     */
    public void broadcastMessage(String message) {
        if (!online) {
            System.out.println("  ❌ " + name + " 未登录，无法发送消息");
            return;
        }

        System.out.println("  📢 " + name + " 群发消息: " + message);
        mediator.broadcastMessage(this.id, message);
    }

    /**
     * 接收消息
     */
    public void receiveMessage(String fromUserId, String message) {
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("HH:mm:ss"));
        String fullMessage = String.format("[%s] %s: %s", timestamp, fromUserId, message);
        messageHistory.add(fullMessage);

        System.out.println("  📥 " + name + " 收到来自 " + fromUserId + " 的消息: " + message);
    }

    /**
     * 查看消息历史
     */
    public void showMessageHistory() {
        System.out.println("\n========== " + name + " 的消息历史 ==========");
        if (messageHistory.isEmpty()) {
            System.out.println("  暂无消息");
        } else {
            messageHistory.forEach(msg -> System.out.println("  " + msg));
        }
        System.out.println("=========================================\n");
    }

    public String getId() { return id; }
    public String getName() { return name; }
    public boolean isOnline() { return online; }
}

/**
 * 聊天组
 */
public class ChatGroup {
    private String groupId;
    private String groupName;
    private List<String> memberIds;
    private List<String> groupMessages;

    public ChatGroup(String groupId, String groupName) {
        this.groupId = groupId;
        this.groupName = groupName;
        this.memberIds = new ArrayList<>();
        this.groupMessages = new ArrayList<>();
    }

    public void addMember(String userId) {
        if (!memberIds.contains(userId)) {
            memberIds.add(userId);
            System.out.println("  👥 用户 " + userId + " 加入群组 " + groupName);
        }
    }

    public void removeMember(String userId) {
        if (memberIds.remove(userId)) {
            System.out.println("  👋 用户 " + userId + " 离开群组 " + groupName);
        }
    }

    public void addMessage(String message) {
        groupMessages.add(message);
    }

    public String getGroupId() { return groupId; }
    public String getGroupName() { return groupName; }
    public List<String> getMemberIds() { return new ArrayList<>(memberIds); }
    public boolean hasMember(String userId) { return memberIds.contains(userId); }
}

/**
 * 中介者接口
 */
public interface ChatMediator {
    void registerUser(User user);
    void sendMessage(String fromUserId, String toUserId, String message);
    void broadcastMessage(String fromUserId, String message);
    void createGroup(String groupId, String groupName);
    void addUserToGroup(String userId, String groupId);
    void sendGroupMessage(String fromUserId, String groupId, String message);
}

/**
 * 具体中介者：聊天室
 */
public class ChatRoom implements ChatMediator {
    private Map<String, User> users;
    private Map<String, ChatGroup> groups;
    private List<String> systemLogs;

    public ChatRoom() {
        this.users = new HashMap<>();
        this.groups = new HashMap<>();
        this.systemLogs = new ArrayList<>();
    }

    @Override
    public void registerUser(User user) {
        users.put(user.getId(), user);
        user.setMediator(this);
        user.login();
        logSystem(user.getName() + " 注册到聊天室");
    }

    @Override
    public void sendMessage(String fromUserId, String toUserId, String message) {
        User fromUser = users.get(fromUserId);
        User toUser = users.get(toUserId);

        if (fromUser == null) {
            System.out.println("  ❌ 发送者不存在");
            return;
        }

        if (toUser == null) {
            System.out.println("  ❌ 接收者不存在");
            logSystem(fromUser.getName() + " 尝试发送消息给不存在的用户 " + toUserId);
            return;
        }

        if (!toUser.isOnline()) {
            System.out.println("  ⚠️ 用户 " + toUser.getName() + " 离线，消息已保存");
            logSystem(fromUser.getName() + " 向离线用户 " + toUser.getName() + " 发送消息");
        }

        // 通过中介者转发消息，而不是用户直接通信
        toUser.receiveMessage(fromUser.getName(), message);
        logSystem(fromUser.getName() + " → " + toUser.getName() + ": " + message);
    }

    @Override
    public void broadcastMessage(String fromUserId, String message) {
        User fromUser = users.get(fromUserId);

        if (fromUser == null) {
            System.out.println("  ❌ 发送者不存在");
            return;
        }

        int sentCount = 0;
        for (User user : users.values()) {
            if (!user.getId().equals(fromUserId) && user.isOnline()) {
                user.receiveMessage(fromUser.getName(), message);
                sentCount++;
            }
        }

        System.out.println("  ✅ 消息已发送给 " + sentCount + " 个在线用户");
        logSystem(fromUser.getName() + " 群发消息给 " + sentCount + " 个用户");
    }

    @Override
    public void createGroup(String groupId, String groupName) {
        if (groups.containsKey(groupId)) {
            System.out.println("  ❌ 群组已存在");
            return;
        }

        ChatGroup group = new ChatGroup(groupId, groupName);
        groups.put(groupId, group);
        System.out.println("  ✅ 创建群组: " + groupName);
        logSystem("创建群组: " + groupName);
    }

    @Override
    public void addUserToGroup(String userId, String groupId) {
        User user = users.get(userId);
        ChatGroup group = groups.get(groupId);

        if (user == null) {
            System.out.println("  ❌ 用户不存在");
            return;
        }

        if (group == null) {
            System.out.println("  ❌ 群组不存在");
            return;
        }

        group.addMember(userId);
        logSystem(user.getName() + " 加入群组 " + group.getGroupName());
    }

    @Override
    public void sendGroupMessage(String fromUserId, String groupId, String message) {
        User fromUser = users.get(fromUserId);
        ChatGroup group = groups.get(groupId);

        if (fromUser == null) {
            System.out.println("  ❌ 发送者不存在");
            return;
        }

        if (group == null) {
            System.out.println("  ❌ 群组不存在");
            return;
        }

        if (!group.hasMember(fromUserId)) {
            System.out.println("  ❌ 您不是该群组成员");
            return;
        }

        System.out.println("  📢 " + fromUser.getName() + " 在群组 " + 
                         group.getGroupName() + " 中发送: " + message);

        String groupMessage = String.format("[%s] %s: %s",
            group.getGroupName(), fromUser.getName(), message);
        group.addMessage(groupMessage);

        int sentCount = 0;
        for (String memberId : group.getMemberIds()) {
            if (!memberId.equals(fromUserId)) {
                User member = users.get(memberId);
                if (member != null && member.isOnline()) {
                    member.receiveMessage(group.getGroupName() + "/" + fromUser.getName(), message);
                    sentCount++;
                }
            }
        }

        System.out.println("  ✅ 群消息已发送给 " + sentCount + " 个成员");
        logSystem(fromUser.getName() + " 在群组 " + group.getGroupName() + " 发送消息");
    }

    /**
     * 获取在线用户列表
     */
    public void showOnlineUsers() {
        System.out.println("\n========== 在线用户列表 ==========");
        int count = 0;
        for (User user : users.values()) {
            if (user.isOnline()) {
                System.out.println("  🟢 " + user.getName() + " (ID: " + user.getId() + ")");
                count++;
            }
        }
        if (count == 0) {
            System.out.println("  当前无在线用户");
        } else {
            System.out.println("总计: " + count + " 个在线用户");
        }
        System.out.println("================================\n");
    }

    /**
     * 显示系统日志
     */
    public void showSystemLogs() {
        System.out.println("\n========== 系统日志 ==========");
        systemLogs.forEach(log -> System.out.println("  " + log));
        System.out.println("============================\n");
    }

    private void logSystem(String message) {
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("HH:mm:ss"));
        systemLogs.add("[" + timestamp + "] " + message);
    }
}

/**
 * 使用示例
 */
public class MediatorDemo {
    public static void main(String[] args) {
        System.out.println("========== 聊天室系统 - 中介者模式 ==========\n");

        // 创建中介者
        ChatRoom chatRoom = new ChatRoom();

        // 创建用户
        System.out.println("【初始化】创建用户");
        User alice = new User("U001", "Alice");
        User bob = new User("U002", "Bob");
        User charlie = new User("U003", "Charlie");
        User david = new User("U004", "David");

        // 注册到聊天室
        System.out.println("\n【场景1】用户注册");
        chatRoom.registerUser(alice);
        chatRoom.registerUser(bob);
        chatRoom.registerUser(charlie);
        chatRoom.registerUser(david);

        chatRoom.showOnlineUsers();

        // 场景2：点对点消息
        System.out.println("【场景2】点对点消息");
        alice.sendMessage("U002", "Hi Bob, 你好！");
        bob.sendMessage("U001", "Hello Alice!");

        // 场景3：群发消息
        System.out.println("\n【场景3】群发消息");
        charlie.broadcastMessage("大家好，我是Charlie！");

        // 场景4：用户离线
        System.out.println("\n【场景4】用户离线后发送消息");
        david.logout();
        alice.sendMessage("U004", "David, 你在吗？");

        // 场景5：创建群组
        System.out.println("\n【场景5】创建群组聊天");
        chatRoom.createGroup("G001", "技术交流群");
        chatRoom.addUserToGroup("U001", "G001");
        chatRoom.addUserToGroup("U002", "G001");
        chatRoom.addUserToGroup("U003", "G001");

        alice.sendMessage("U002", "Bob，要不要加入技术交流群？");

        // 场景6：群组消息
        System.out.println("\n【场景6】群组消息");
        chatRoom.sendGroupMessage("U001", "G001", "大家好，欢迎加入技术交流群！");
        chatRoom.sendGroupMessage("U002", "G001", "很高兴认识大家！");
        chatRoom.sendGroupMessage("U003", "G001", "一起学习进步！");

        // 场景7：非群成员发送消息
        System.out.println("\n【场景7】非群成员尝试发送群消息");
        chatRoom.sendGroupMessage("U004", "G001", "我也想发言");

        // 显示消息历史
        alice.showMessageHistory();
        bob.showMessageHistory();

        // 显示系统日志
        chatRoom.showSystemLogs();

        // 中介者模式的优势
        System.out.println("========== 中介者模式的优势 ==========");
        System.out.println("1. 降低耦合: 对象之间不直接引用");
        System.out.println("2. 集中控制: 交互逻辑集中在中介者");
        System.out.println("3. 简化对象: 对象不需要知道其他对象");
        System.out.println("4. 易于维护: 交互逻辑修改只涉及中介者");

        System.out.println("\n========== 如果不使用中介者模式 ==========");
        System.out.println("❌ 用户之间直接通信:");
        System.out.println("  class User {");
        System.out.println("    List<User> contacts;");
        System.out.println("    void sendTo(User user) {");
        System.out.println("      user.receive(message);");
        System.out.println("    }");
        System.out.println("  }");
        System.out.println("\n问题:");
        System.out.println("  - 用户之间紧密耦合");
        System.out.println("  - 每个用户都要维护其他用户的引用");
        System.out.println("  - 消息路由逻辑分散");
        System.out.println("  - 难以添加新功能（如群组、离线消息）");

        System.out.println("\n✅ 使用中介者模式:");
        System.out.println("  class User {");
        System.out.println("    ChatMediator mediator;");
        System.out.println("    void send(String toId, String msg) {");
        System.out.println("      mediator.sendMessage(id, toId, msg);");
        System.out.println("    }");
        System.out.println("  }");
        System.out.println("\n优势:");
        System.out.println("  - 用户只依赖中介者");
        System.out.println("  - 交互逻辑集中管理");
        System.out.println("  - 易于扩展新功能");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. 聊天室系统");
        System.out.println("2. MVC架构中的Controller");
        System.out.println("3. 机场调度系统");
        System.out.println("4. GUI对话框（组件间交互）");
        System.out.println("5. 消息队列系统");
        System.out.println("6. 游戏中的事件系统");

        System.out.println("\n========== 中介者模式 vs 观察者模式 ==========");
        System.out.println("中介者模式:");
        System.out.println("  - 集中式通信");
        System.out.println("  - 对象通过中介者交互");
        System.out.println("  - 中介者了解所有对象");

        System.out.println("\n观察者模式:");
        System.out.println("  - 分布式通信");
        System.out.println("  - 主题直接通知观察者");
        System.out.println("  - 主题不关心观察者细节");
    }
}
```

### 21. 备忘录模式（Memento Pattern）

**使用场景**：

* 需要保存对象状态
* 需要撤销操作
* 游戏存档
* 事务回滚

**好处：**

- 保存和恢复对象状态
- 不破坏封装性
- 简化原发器类

**解决的问题：**

- 需要保存对象历史状态
- 实现撤销/重做功能
- 状态恢复

**缺点：**

- 消耗内存（保存多个状态）
- 可能影响性能

**详细案例：文本编辑器**

```java
/**
 * 备忘录：文本状态
 */
public class TextMemento {
    private final String content;
    private final int cursorPosition;
    private final LocalDateTime timestamp;

    public TextMemento(String content, int cursorPosition) {
        this.content = content;
        this.cursorPosition = cursorPosition;
        this.timestamp = LocalDateTime.now();
    }

    public String getContent() {
        return content;
    }

    public int getCursorPosition() {
        return cursorPosition;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public String getInfo() {
        return String.format("[%s] 内容长度: %d, 光标位置: %d",
            timestamp.format(DateTimeFormatter.ofPattern("HH:mm:ss")),
            content.length(), cursorPosition);
    }
}

/**
 * 原发器：文本编辑器
 */
public class TextEditor {
    private StringBuilder content;
    private int cursorPosition;
    private String fileName;

    public TextEditor(String fileName) {
        this.fileName = fileName;
        this.content = new StringBuilder();
        this.cursorPosition = 0;
    }

    /**
     * 输入文本
     */
    public void type(String text) {
        content.insert(cursorPosition, text);
        cursorPosition += text.length();
        System.out.println("  ⌨️ 输入: \"" + text + "\"");
        showStatus();
    }

    /**
     * 删除文本
     */
    public void delete(int length) {
        if (cursorPosition < length) {
            System.out.println("  ❌ 删除失败：光标前字符不足");
            return;
        }

        String deleted = content.substring(cursorPosition - length, cursorPosition);
        content.delete(cursorPosition - length, cursorPosition);
        cursorPosition -= length;
        System.out.println("  🗑️ 删除: \"" + deleted + "\"");
        showStatus();
    }

    /**
     * 移动光标
     */
    public void moveCursor(int position) {
        if (position < 0 || position > content.length()) {
            System.out.println("  ❌ 光标位置无效");
            return;
        }
        cursorPosition = position;
        System.out.println("  ↔️ 光标移动到位置: " + position);
    }

    /**
     * 显示当前状态
     */
    public void showStatus() {
        System.out.println("  📝 当前内容: \"" + content + "\"");
        System.out.println("  📍 光标位置: " + cursorPosition);
    }

    /**
     * 创建备忘录
     */
    public TextMemento save() {
        System.out.println("  💾 保存状态");
        return new TextMemento(content.toString(), cursorPosition);
    }

    /**
     * 恢复备忘录
     */
    public void restore(TextMemento memento) {
        if (memento == null) {
            System.out.println("  ❌ 无效的备忘录");
            return;
        }

        this.content = new StringBuilder(memento.getContent());
        this.cursorPosition = memento.getCursorPosition();
        System.out.println("  ♻️ 恢复状态: " + memento.getInfo());
        showStatus();
    }

    public String getContent() {
        return content.toString();
    }

    public String getFileName() {
        return fileName;
    }
}

/**
 * 管理者：历史记录管理器
 */
public class History {
    private Stack<TextMemento> undoStack;
    private Stack<TextMemento> redoStack;
    private int maxHistorySize;

    public History(int maxHistorySize) {
        this.undoStack = new Stack<>();
        this.redoStack = new Stack<>();
        this.maxHistorySize = maxHistorySize;
    }

    /**
     * 保存状态
     */
    public void push(TextMemento memento) {
        if (undoStack.size() >= maxHistorySize) {
            // 移除最旧的记录
            undoStack.remove(0);
        }
        undoStack.push(memento);
        // 保存新状态时清空重做栈
        redoStack.clear();
        System.out.println("  📚 历史记录已保存 (共" + undoStack.size() + "条)");
    }

    /**
     * 撤销
     */
    public TextMemento undo() {
        if (undoStack.isEmpty()) {
            System.out.println("  ⚠️ 无可撤销的操作");
            return null;
        }

        TextMemento memento = undoStack.pop();
        redoStack.push(memento);

        if (undoStack.isEmpty()) {
            System.out.println("  ⏪ 撤销到初始状态");
            return null;
        }

        System.out.println("  ⏪ 执行撤销");
        return undoStack.peek();
    }

    /**
     * 重做
     */
    public TextMemento redo() {
        if (redoStack.isEmpty()) {
            System.out.println("  ⚠️ 无可重做的操作");
            return null;
        }

        TextMemento memento = redoStack.pop();
        undoStack.push(memento);
        System.out.println("  ⏩ 执行重做");
        return memento;
    }

    /**
     * 显示历史记录
     */
    public void showHistory() {
        System.out.println("\n========== 历史记录 ==========");
        if (undoStack.isEmpty()) {
            System.out.println("  暂无历史记录");
        } else {
            for (int i = 0; i < undoStack.size(); i++) {
                TextMemento memento = undoStack.get(i);
                System.out.println("  " + (i + 1) + ". " + memento.getInfo());
            }
        }
        System.out.println("============================\n");
    }

    public boolean canUndo() {
        return !undoStack.isEmpty();
    }

    public boolean canRedo() {
        return !redoStack.isEmpty();
    }

    public int getHistorySize() {
        return undoStack.size();
    }
}

/**
 * 使用示例
 */
public class MementoDemo {
    public static void main(String[] args) {
        System.out.println("========== 文本编辑器 - 备忘录模式 ==========\n");

        // 创建编辑器和历史管理器
        TextEditor editor = new TextEditor("document.txt");
        History history = new History(10);

        System.out.println("【场景1】编辑文本");

        // 输入第一段文字
        editor.type("Hello");
        history.push(editor.save());

        editor.type(" World");
        history.push(editor.save());

        editor.type("!");
        history.push(editor.save());

        // 显示历史
        history.showHistory();

        // 场景2：撤销操作
        System.out.println("\n【场景2】撤销操作");

        System.out.println("\n第1次撤销:");
        TextMemento memento = history.undo();
        if (memento != null) {
            editor.restore(memento);
        }

        System.out.println("\n第2次撤销:");
        memento = history.undo();
        if (memento != null) {
            editor.restore(memento);
        }

        // 场景3：重做操作
        System.out.println("\n【场景3】重做操作");

        System.out.println("\n第1次重做:");
        memento = history.redo();
        if (memento != null) {
            editor.restore(memento);
        }

        // 场景4：撤销后修改
        System.out.println("\n【场景4】撤销后继续编辑");

        editor.type(" from Java");
        history.push(editor.save());

        System.out.println("\n尝试重做（应该失败，因为已经修改）:");
        history.redo();

        // 场景5：删除操作
        System.out.println("\n【场景5】删除操作");

        editor.moveCursor(editor.getContent().length());
        editor.delete(5);
        history.push(editor.save());

        editor.delete(6);
        history.push(editor.save());

        // 显示历史
        history.showHistory();

        // 场景6：多次撤销
        System.out.println("\n【场景6】连续撤销到开始");

        while (history.canUndo()) {
            memento = history.undo();
            if (memento != null) {
                editor.restore(memento);
            }
            System.out.println();
        }

        // 场景7：测试历史记录上限
        System.out.println("\n【场景7】测试历史记录上限（最多10条）");

        TextEditor editor2 = new TextEditor("test.txt");
        History history2 = new History(5);

        for (int i = 1; i <= 8; i++) {
            editor2.type("Step" + i + " ");
            history2.push(editor2.save());
        }

        System.out.println("历史记录数量: " + history2.getHistorySize() + " (上限5条)");
        history2.showHistory();

        // 备忘录模式的优势
        System.out.println("\n========== 备忘录模式的优势 ==========");
        System.out.println("1. 状态保存: 轻松保存和恢复对象状态");
        System.out.println("2. 封装性: 不暴露对象内部结构");
        System.out.println("3. 简化原发器: 状态管理交给管理者");
        System.out.println("4. 实现撤销/重做: 轻松实现历史功能");

        System.out.println("\n========== 如果不使用备忘录模式 ==========");
        System.out.println("❌ 直接在编辑器中管理历史:");
        System.out.println("  class Editor {");
        System.out.println("    List<String> history;");
        System.out.println("    void undo() {");
        System.out.println("      // 复杂的状态恢复逻辑");
        System.out.println("    }");
        System.out.println("  }");
        System.out.println("\n问题:");
        System.out.println("  - 违反单一职责原则");
        System.out.println("  - 状态管理逻辑复杂");
        System.out.println("  - 难以扩展");

        System.out.println("\n✅ 使用备忘录模式:");
        System.out.println("  - 编辑器只负责编辑");
        System.out.println("  - 历史管理器负责状态管理");
        System.out.println("  - 职责清晰，易于维护");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. 文本编辑器的撤销/重做");
        System.out.println("2. 游戏存档");
        System.out.println("3. 数据库事务回滚");
        System.out.println("4. 浏览器后退功能");
        System.out.println("5. 图形编辑器");
        System.out.println("6. IDE的代码编辑");

        System.out.println("\n========== 备忘录模式的注意事项 ==========");
        System.out.println("⚠️ 1. 内存消耗: 保存大量状态会消耗内存");
        System.out.println("   解决: 限制历史记录数量");
        System.out.println("⚠️ 2. 性能影响: 频繁保存状态可能影响性能");
        System.out.println("   解决: 增量保存或压缩状态");
        System.out.println("⚠️ 3. 序列化问题: 复杂对象的保存和恢复");
        System.out.println("   解决: 使用深拷贝或序列化机制");
    }
}
```

### 22. 访问者模式（Visitor Pattern）

**使用场景**：

* 对象结构稳定
* 需要多种操作
* 数据结构与操作分离
* 编译器语法树

**好处：**

- 增加新操作容易
- 将相关操作集中
- 访问者可以访问不同类型对象

**解决的问题：**

- 需要对对象结构进行多种不同操作
- 对象结构稳定但操作多变
- 避免污染对象类

**缺点：**

- 增加新元素困难
- 破坏封装性
- 依赖具体类

**详细案例：公司员工薪资系统**

```java
/**
 * 元素接口
 */
public interface Employee {
    void accept(Visitor visitor);
    String getName();
    String getDepartment();
}

/**
 * 具体元素：工程师
 */
public class Engineer implements Employee {
    private String name;
    private double baseSalary;
    private int codeLines;
    private int bugFixed;

    public Engineer(String name, double baseSalary, int codeLines, int bugFixed) {
        this.name = name;
        this.baseSalary = baseSalary;
        this.codeLines = codeLines;
        this.bugFixed = bugFixed;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    @Override
    public String getName() { return name; }

    @Override
    public String getDepartment() { return "技术部"; }

    public double getBaseSalary() { return baseSalary; }
    public int getCodeLines() { return codeLines; }
    public int getBugFixed() { return bugFixed; }
}

/**
 * 具体元素：经理
 */
public class Manager implements Employee {
    private String name;
    private double baseSalary;
    private int teamSize;
    private double performanceScore;

    public Manager(String name, double baseSalary, int teamSize, double performanceScore) {
        this.name = name;
        this.baseSalary = baseSalary;
        this.teamSize = teamSize;
        this.performanceScore = performanceScore;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    @Override
    public String getName() { return name; }

    @Override
    public String getDepartment() { return "管理层"; }

    public double getBaseSalary() { return baseSalary; }
    public int getTeamSize() { return teamSize; }
    public double getPerformanceScore() { return performanceScore; }
}

/**
 * 具体元素：销售
 */
public class Salesperson implements Employee {
    private String name;
    private double baseSalary;
    private double salesAmount;
    private int customerCount;

    public Salesperson(String name, double baseSalary, double salesAmount, int customerCount) {
        this.name = name;
        this.baseSalary = baseSalary;
        this.salesAmount = salesAmount;
        this.customerCount = customerCount;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    @Override
    public String getName() { return name; }

    @Override
    public String getDepartment() { return "销售部"; }

    public double getBaseSalary() { return baseSalary; }
    public double getSalesAmount() { return salesAmount; }
    public int getCustomerCount() { return customerCount; }
}

/**
 * 访问者接口
 */
public interface Visitor {
    void visit(Engineer engineer);
    void visit(Manager manager);
    void visit(Salesperson salesperson);
}

/**
 * 具体访问者：薪资计算器
 */
public class SalaryCalculator implements Visitor {
    private Map<String, Double> salaries = new HashMap<>();

    @Override
    public void visit(Engineer engineer) {
        // 工程师薪资 = 基本工资 + 代码行数奖金 + Bug修复奖金
        double codeBonus = engineer.getCodeLines() * 0.1;
        double bugBonus = engineer.getBugFixed() * 50;
        double totalSalary = engineer.getBaseSalary() + codeBonus + bugBonus;

        salaries.put(engineer.getName(), totalSalary);

        System.out.println("  👨‍💻 " + engineer.getName() + " (工程师)");
        System.out.println("    基本工资: ¥" + String.format("%.2f", engineer.getBaseSalary()));
        System.out.println("    代码奖金: ¥" + String.format("%.2f", codeBonus) + 
                         " (" + engineer.getCodeLines() + "行)");
        System.out.println("    修复Bug奖金: ¥" + String.format("%.2f", bugBonus) + 
                         " (" + engineer.getBugFixed() + "个)");
        System.out.println("    总薪资: ¥" + String.format("%.2f", totalSalary));
    }

    @Override
    public void visit(Manager manager) {
        // 经理薪资 = 基本工资 + 团队规模奖金 + 绩效奖金
        double teamBonus = manager.getTeamSize() * 500;
        double performanceBonus = manager.getBaseSalary() * manager.getPerformanceScore();
        double totalSalary = manager.getBaseSalary() + teamBonus + performanceBonus;

        salaries.put(manager.getName(), totalSalary);

        System.out.println("  👔 " + manager.getName() + " (经理)");
        System.out.println("    基本工资: ¥" + String.format("%.2f", manager.getBaseSalary()));
        System.out.println("    团队奖金: ¥" + String.format("%.2f", teamBonus) + 
                         " (管理" + manager.getTeamSize() + "人)");
        System.out.println("    绩效奖金: ¥" + String.format("%.2f", performanceBonus) + 
                         " (绩效" + manager.getPerformanceScore() + ")");
        System.out.println("    总薪资: ¥" + String.format("%.2f", totalSalary));
    }

    @Override
    public void visit(Salesperson salesperson) {
        // 销售薪资 = 基本工资 + 销售提成 + 客户奖金
        double salesCommission = salesperson.getSalesAmount() * 0.05;
        double customerBonus = salesperson.getCustomerCount() * 100;
        double totalSalary = salesperson.getBaseSalary() + salesCommission + customerBonus;

        salaries.put(salesperson.getName(), totalSalary);

        System.out.println("  💼 " + salesperson.getName() + " (销售)");
        System.out.println("    基本工资: ¥" + String.format("%.2f", salesperson.getBaseSalary()));
        System.out.println("    销售提成: ¥" + String.format("%.2f", salesCommission) + 
                         " (销售额¥" + String.format("%.2f", salesperson.getSalesAmount()) + ")");
        System.out.println("    客户奖金: ¥" + String.format("%.2f", customerBonus) + 
                         " (" + salesperson.getCustomerCount() + "个客户)");
        System.out.println("    总薪资: ¥" + String.format("%.2f", totalSalary));
    }

    public double getTotalSalary(String name) {
        return salaries.getOrDefault(name, 0.0);
    }

    public double getAllSalaries() {
        return salaries.values().stream().mapToDouble(Double::doubleValue).sum();
    }
}

/**
 * 具体访问者：绩效评估器
 */
public class PerformanceEvaluator implements Visitor {
    private Map<String, String> evaluations = new HashMap<>();

    @Override
    public void visit(Engineer engineer) {
        String rating;
        if (engineer.getCodeLines() > 5000 && engineer.getBugFixed() > 20) {
            rating = "优秀⭐⭐⭐⭐⭐";
        } else if (engineer.getCodeLines() > 3000 && engineer.getBugFixed() > 10) {
            rating = "良好⭐⭐⭐⭐";
        } else {
            rating = "一般⭐⭐⭐";
        }

        evaluations.put(engineer.getName(), rating);
        System.out.println("  " + engineer.getName() + ": " + rating);
        System.out.println("    代码量: " + engineer.getCodeLines() + "行");
        System.out.println("    Bug修复: " + engineer.getBugFixed() + "个");
    }

    @Override
    public void visit(Manager manager) {
        String rating;
        if (manager.getPerformanceScore() >= 0.9) {
            rating = "优秀⭐⭐⭐⭐⭐";
        } else if (manager.getPerformanceScore() >= 0.7) {
            rating = "良好⭐⭐⭐⭐";
        } else {
            rating = "一般⭐⭐⭐";
        }

        evaluations.put(manager.getName(), rating);
        System.out.println("  " + manager.getName() + ": " + rating);
        System.out.println("    团队规模: " + manager.getTeamSize() + "人");
        System.out.println("    绩效分数: " + manager.getPerformanceScore());
    }

    @Override
    public void visit(Salesperson salesperson) {
        String rating;
        if (salesperson.getSalesAmount() > 100000 && salesperson.getCustomerCount() > 50) {
            rating = "优秀⭐⭐⭐⭐⭐";
        } else if (salesperson.getSalesAmount() > 50000 && salesperson.getCustomerCount() > 30) {
            rating = "良好⭐⭐⭐⭐";
        } else {
            rating = "一般⭐⭐⭐";
        }

        evaluations.put(salesperson.getName(), rating);
        System.out.println("  " + salesperson.getName() + ": " + rating);
        System.out.println("    销售额: ¥" + String.format("%.2f", salesperson.getSalesAmount()));
        System.out.println("    客户数: " + salesperson.getCustomerCount());
    }
}

/**
 * 具体访问者：年度报告生成器
 */
public class AnnualReportGenerator implements Visitor {
    private StringBuilder report = new StringBuilder();

    @Override
    public void visit(Engineer engineer) {
        report.append(String.format("工程师 %s: 完成代码%d行, 修复Bug%d个\n",
            engineer.getName(), engineer.getCodeLines(), engineer.getBugFixed()));
    }

    @Override
    public void visit(Manager manager) {
        report.append(String.format("经理 %s: 管理团队%d人, 绩效%.2f\n",
            manager.getName(), manager.getTeamSize(), manager.getPerformanceScore()));
    }

    @Override
    public void visit(Salesperson salesperson) {
        report.append(String.format("销售 %s: 销售额¥%.2f, 客户%d个\n",
            salesperson.getName(), salesperson.getSalesAmount(), salesperson.getCustomerCount()));
    }

    public String getReport() {
        return report.toString();
    }
}

/**
 * 公司（对象结构）
 */
public class Company {
    private List<Employee> employees = new ArrayList<>();

    public void addEmployee(Employee employee) {
        employees.add(employee);
    }

    public void accept(Visitor visitor) {
        for (Employee employee : employees) {
            employee.accept(visitor);
        }
    }
}

/**
 * 使用示例
 */
public class VisitorDemo {
    public static void main(String[] args) {
        System.out.println("========== 员工薪资系统 - 访问者模式 ==========\n");

        // 创建公司和员工
        Company company = new Company();

        company.addEmployee(new Engineer("张三", 15000, 6000, 25));
        company.addEmployee(new Engineer("李四", 18000, 8000, 30));
        company.addEmployee(new Manager("王五", 25000, 10, 0.95));
        company.addEmployee(new Manager("赵六", 30000, 15, 0.88));
        company.addEmployee(new Salesperson("孙七", 8000, 120000, 60));
        company.addEmployee(new Salesperson("周八", 8000, 80000, 45));

        // 场景1：计算薪资
        System.out.println("【场景1】计算员工薪资\n");
        SalaryCalculator salaryCalculator = new SalaryCalculator();
        company.accept(salaryCalculator);

        System.out.println("\n总薪资支出: ¥" + 
            String.format("%.2f", salaryCalculator.getAllSalaries()));

        // 场景2：绩效评估
        System.out.println("\n【场景2】员工绩效评估\n");
        PerformanceEvaluator evaluator = new PerformanceEvaluator();
        company.accept(evaluator);

        // 场景3：生成年度报告
        System.out.println("\n【场景3】生成年度报告\n");
        AnnualReportGenerator reportGenerator = new AnnualReportGenerator();
        company.accept(reportGenerator);
        System.out.println(reportGenerator.getReport());

        // 访问者模式的优势
        System.out.println("========== 访问者模式的优势 ==========");
        System.out.println("1. 易于添加操作: 新增访问者即可");
        System.out.println("2. 相关操作集中: 同类操作在一个访问者中");
        System.out.println("3. 不修改元素: 元素类无需修改");
        System.out.println("4. 符合开闭原则: 对操作扩展开放");

        System.out.println("\n========== 如果不使用访问者模式 ==========");
        System.out.println("❌ 在每个员工类中实现所有操作:");
        System.out.println("  class Engineer {");
        System.out.println("    double calculateSalary() { ... }");
        System.out.println("    String evaluatePerformance() { ... }");
        System.out.println("    String generateReport() { ... }");
        System.out.println("  }");
        System.out.println("\n问题:");
        System.out.println("  - 每个类都需要实现所有操作");
        System.out.println("  - 新增操作需要修改所有类");
        System.out.println("  - 违反单一职责原则");

        System.out.println("\n✅ 使用访问者模式:");
        System.out.println("  - 员工类只负责数据");
        System.out.println("  - 操作封装在访问者中");
        System.out.println("  - 新增操作只需新增访问者");

        System.out.println("\n========== 实际应用场景 ==========");
        System.out.println("1. 编译器（AST节点访问）");
        System.out.println("2. 对象结构遍历（文件系统）");
        System.out.println("3. 报表生成");
        System.out.println("4. 对象序列化");
        System.out.println("5. 数据导出（XML、JSON、CSV）");

        System.out.println("\n========== 访问者模式的适用条件 ==========");
        System.out.println("✅ 对象结构稳定（元素类很少变化）");
        System.out.println("✅ 需要对对象进行多种不同操作");
        System.out.println("✅ 操作经常变化");

        System.out.println("\n❌ 不适用的情况:");
        System.out.println("  - 对象结构经常变化");
        System.out.println("  - 操作较少且稳定");
        System.out.println("  - 需要严格的封装性");
    }
}
```

### 23. 解释器模式（Interpreter）

**使用场景**：

- 特定类型问题频繁发生
- 简单语法解释器
- 正则表达式
- SQL解析

**解决问题**：

- 特定领域语言
- 文法表示

**优点**：

- 容易改变和扩展文法
- 实现文法容易

**缺点**：

- 执行效率低
- 复杂文法难以维护

```java
import java.util.Map;
import java.util.HashMap;

// 表达式接口
interface Expression {
    boolean interpret(Map<String, Boolean> context);
}

// 终结符表达式
class Variable implements Expression {
    private String name;

    public Variable(String name) {
        this.name = name;
    }

    @Override
    public boolean interpret(Map<String, Boolean> context) {
        return context.getOrDefault(name, false);
    }
}

// 非终结符表达式
class AndExpression implements Expression {
    private Expression expr1;
    private Expression expr2;

    public AndExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    @Override
    public boolean interpret(Map<String, Boolean> context) {
        return expr1.interpret(context) && expr2.interpret(context);
    }
}

class OrExpression implements Expression {
    private Expression expr1;
    private Expression expr2;

    public OrExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    @Override
    public boolean interpret(Map<String, Boolean> context) {
        return expr1.interpret(context) || expr2.interpret(context);
    }
}

class NotExpression implements Expression {
    private Expression expr;

    public NotExpression(Expression expr) {
        this.expr = expr;
    }

    @Override
    public boolean interpret(Map<String, Boolean> context) {
        return !expr.interpret(context);
    }
}

// 构建解析树
class ExpressionBuilder {
    public static Expression buildExpression(String expression) {
        // 简化实现，实际应用中需要完整的语法解析
        if (expression.contains("AND")) {
            String[] parts = expression.split(" AND ");
            return new AndExpression(new Variable(parts[0].trim()), 
                                   new Variable(parts[1].trim()));
        } else if (expression.contains("OR")) {
            String[] parts = expression.split(" OR ");
            return new OrExpression(new Variable(parts[0].trim()), 
                                  new Variable(parts[1].trim()));
        } else if (expression.startsWith("NOT ")) {
            return new NotExpression(new Variable(expression.substring(4).trim()));
        } else {
            return new Variable(expression.trim());
        }
    }
}

// 使用示例
public class InterpreterDemo {
    public static void main(String[] args) {
        // 创建上下文
        Map<String, Boolean> context = new HashMap<>();
        context.put("A", true);
        context.put("B", false);
        context.put("C", true);

        // 构建表达式
        Expression expr1 = ExpressionBuilder.buildExpression("A AND B");
        Expression expr2 = ExpressionBuilder.buildExpression("A OR B");
        Expression expr3 = ExpressionBuilder.buildExpression("NOT C");
        Expression expr4 = ExpressionBuilder.buildExpression("A AND B OR C");

        // 解释表达式
        System.out.println("A AND B = " + expr1.interpret(context));
        System.out.println("A OR B = " + expr2.interpret(context));
        System.out.println("NOT C = " + expr3.interpret(context));

        // 复合表达式
        Expression expr5 = new AndExpression(
            new Variable("A"),
            new OrExpression(new Variable("B"), new Variable("C"))
        );
        System.out.println("A AND (B OR C) = " + expr5.interpret(context));
    }
}
```
